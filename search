#!/bin/bash

# Search - Outil de recherche avancé pour fichiers et dossiers
# Version: 1.0.1
# Description: Programme de recherche global pour rechercher facilement dans le dossier courant

# Couleurs pour l'affichage
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Variables par défaut
SEARCH_DIR="."
SEARCH_PATTERN=""
SEARCH_TYPE="both"  # both, files, dirs
CASE_SENSITIVE=true
REGEX_MODE=false
EXACT_MATCH=false  # Recherche exacte du nom (non stricte)
USE_SPOTLIGHT=false  # Utiliser l'index Spotlight de macOS
INTERACTIVE_MODE=false  # Mode interactif par défaut
SHOW_HIDDEN=false
MAX_DEPTH="1"  # Profondeur par défaut de 1 (répertoire courant uniquement)
MIN_SIZE=""
MAX_SIZE=""
MODIFIED_DAYS=""
OUTPUT_FORMAT="detailed"  # detailed, simple, json

# Fonction d'aide
show_help() {
    echo -e "${WHITE}Search - Outil de recherche avancé${NC}"
    echo -e "${CYAN}Usage: search [OPTIONS] [PATTERN] [DIRECTORY]${NC}"
    echo ""
    echo -e "${YELLOW}COMPORTEMENT PAR DÉFAUT:${NC}"
    echo -e "  ${GREEN}search${NC}                      # Affiche le contenu du dossier courant"
    echo -e "  ${GREEN}search PATTERN${NC}              # Recherche PATTERN dans le dossier courant"
    echo ""
    echo -e "${YELLOW}OPTIONS:${NC}"
    echo -e "  ${GREEN}-h, --help${NC}              Afficher cette aide"
    echo -e "  ${GREEN}-d, --directory DIR${NC}     Répertoire de recherche (défaut: .)"
    echo -e "  ${GREEN}-t, --type TYPE${NC}         Type: files, dirs, both (défaut: both)"
    echo -e "  ${GREEN}-ic, --ignore-case${NC}       Ignorer la casse"
    echo -e "  ${GREEN}-r, --regex${NC}             Utiliser les expressions régulières"
    echo -e "  ${GREEN}-e, --exact${NC}             Recherche exacte du nom (non stricte)"
    echo -e "  ${GREEN}-s, --spotlight${NC}         Utiliser l'index Spotlight de macOS (plus rapide, limitation de répertoire limitée)"
    echo -e "  ${GREEN}-i, --interactive${NC}       Mode interactif pour naviguer dans les dossiers"
    echo -e "  ${GREEN}-a, --all${NC}               Inclure les fichiers cachés"
    echo -e "  ${GREEN}-mdh, --max-depth N${NC}           Profondeur maximale de recherche (défaut: 1)"
    echo -e "  ${GREEN}-mis, --min-size SIZE${NC}         Taille minimale (ex: 1M, 100K)"
    echo -e "  ${GREEN}-mas, --max-size SIZE${NC}         Taille maximale (ex: 10M, 1G)"
    echo -e "  ${GREEN}-md, --modified N${NC}            Modifié dans les N derniers jours"
    echo -e "  ${GREEN}-fo, --format FORMAT${NC}         Format de sortie: detailed, simple, json"
    echo ""
    echo -e "${YELLOW}EXEMPLES:${NC}"
    echo -e "  ${CYAN}search${NC}                                 # Afficher le contenu du dossier courant"
    echo -e "  ${CYAN}search \"*.py\"${NC}                          # Rechercher tous les fichiers Python"
    echo -e "  ${CYAN}search -t files \"config\"${NC}               # Rechercher fichiers contenant 'config'"
    echo -e "  ${CYAN}search -e \"mini\"${NC}                       # Rechercher fichiers/dossiers nommés exactement 'mini'"
    echo -e "  ${CYAN}search -s \"python\"${NC}                     # Recherche rapide avec Spotlight"
    echo -e "  ${CYAN}search -i${NC}                              # Mode interactif pour naviguer"
    echo -e "  ${CYAN}search -i -d /chemin/vers/le/dossier${NC}   # Mode interactif dans un dossier spécifique"
    echo -e "  ${CYAN}search -r \"^[A-Z].*\"${NC}                   # Rechercher avec regex"
    echo -e "  ${CYAN}search --min-size 1M --max-size 10M${NC}    # Fichiers entre 1M et 10M"
    echo -e "  ${CYAN}search --modified 7 \"*.log\"${NC}            # Fichiers .log modifiés cette semaine"
    echo ""
}

# Fonction pour convertir les tailles
parse_size() {
    local size=$1
    if [[ $size =~ ^([0-9]+)([KkMmGg]?)$ ]]; then
        local num=${BASH_REMATCH[1]}
        local unit=${BASH_REMATCH[2],,}
        case $unit in
            k) echo $((num * 1024)) ;;
            m) echo $((num * 1024 * 1024)) ;;
            g) echo $((num * 1024 * 1024 * 1024)) ;;
            *) echo $num ;;
        esac
    else
        echo "0"
    fi
}

# Fonction de recherche avec Spotlight
search_spotlight() {
    local pattern="$1"
    local search_dir="$2"
    
    # Vérifier que mdfind est disponible
    if ! command -v mdfind &> /dev/null; then
        echo -e "${RED}Erreur: mdfind n'est pas disponible. Spotlight n'est pas installé ou activé.${NC}"
        return 1
    fi
    
    # Avertissement pour les chemins relatifs avec Spotlight
    if [[ "$search_dir" == "." || "$search_dir" == "./" ]]; then
        echo -e "${YELLOW}Note: Spotlight ne peut pas se limiter strictement au répertoire courant.${NC}"
        echo -e "${YELLOW}Utilisez la recherche classique (sans -s) pour une limitation précise.${NC}"
        echo ""
        # Basculement vers la recherche classique
        search_files "$pattern" "$search_dir"
        return 0
    fi
    
    # Construire la requête Spotlight
    local mdfind_cmd="mdfind"
    
    # Ajouter le répertoire de recherche
    # Convertir le chemin relatif en chemin absolu
    local abs_search_dir
    if [[ "$search_dir" == "." || "$search_dir" == "./" ]]; then
        abs_search_dir=$(pwd)
    else
        abs_search_dir=$(cd "$search_dir" 2>/dev/null && pwd || echo "$search_dir")
    fi
    
    # Toujours utiliser -onlyin pour limiter la recherche
    mdfind_cmd="$mdfind_cmd -onlyin \"$abs_search_dir\""
    
    # Construire la requête selon le type de recherche
    local query=""
    
    if [[ "$EXACT_MATCH" == true ]]; then
        # Recherche exacte du nom
        query="kMDItemDisplayName == '$pattern'"
    elif [[ "$REGEX_MODE" == true ]]; then
        # Mode regex (Spotlight ne supporte pas les regex complexes, on utilise une approximation)
        query="kMDItemDisplayName == '*$pattern*'"
    else
        # Recherche partielle
        query="kMDItemDisplayName == '*$pattern*'"
    fi
    
    # Ajouter le type de fichier
    if [[ "$SEARCH_TYPE" == "files" ]]; then
        query="$query && kMDItemContentType != 'public.folder'"
    elif [[ "$SEARCH_TYPE" == "dirs" ]]; then
        query="$query && kMDItemContentType == 'public.folder'"
    fi
    
    # Ajouter les filtres de taille si spécifiés
    if [[ -n "$MIN_SIZE" ]]; then
        local min_bytes=$(parse_size "$MIN_SIZE")
        query="$query && kMDItemFSSize >= $min_bytes"
    fi
    
    if [[ -n "$MAX_SIZE" ]]; then
        local max_bytes=$(parse_size "$MAX_SIZE")
        query="$query && kMDItemFSSize <= $max_bytes"
    fi
    
    # Ajouter le filtre de date
    if [[ -n "$MODIFIED_DAYS" ]]; then
        local days_ago=$(date -v-${MODIFIED_DAYS}d +%Y-%m-%d 2>/dev/null || date -d "${MODIFIED_DAYS} days ago" +%Y-%m-%d 2>/dev/null)
        query="$query && kMDItemFSContentChangeDate >= '$days_ago'"
    fi
    
    # Exécuter la recherche Spotlight
    eval "$mdfind_cmd \"$query\"" 2>/dev/null | while IFS= read -r file; do
        if [[ -n "$file" && -e "$file" ]]; then
            # Vérification stricte : le fichier doit être dans le répertoire de recherche
            if [[ "$file" != "$abs_search_dir"* ]]; then
                continue
            fi
            
            # Vérifier la profondeur si spécifiée
            if [[ -n "$MAX_DEPTH" && "$MAX_DEPTH" != "1" ]]; then
                # Calculer la profondeur relative au répertoire de recherche
                local relative_path="${file#$abs_search_dir/}"
                local depth=$(echo "$relative_path" | tr -cd '/' | wc -c)
                depth=$((depth + 1))
                
                # Ignorer si la profondeur dépasse la limite
                if [[ $depth -gt $MAX_DEPTH ]]; then
                    continue
                fi
            fi
            
            # Vérifier les fichiers cachés si nécessaire
            if [[ "$SHOW_HIDDEN" == false ]]; then
                local basename=$(basename "$file")
                if [[ "$basename" =~ ^\..* ]]; then
                    continue
                fi
            fi
            
            display_result "$file"
        fi
    done
}

# Fonction de recherche principale
search_files() {
    local pattern="$1"
    local search_dir="$2"
    
    # Construire la commande find
    local find_cmd="find \"$search_dir\""
    
    # Ajouter la profondeur maximale
    if [[ -n "$MAX_DEPTH" ]]; then
        find_cmd="$find_cmd -maxdepth $MAX_DEPTH"
    fi
    
    # Ajouter le type de recherche
    case $SEARCH_TYPE in
        files) find_cmd="$find_cmd -type f" ;;
        dirs) find_cmd="$find_cmd -type d" ;;
    esac
    
    # Ajouter les fichiers cachés
    if [[ "$SHOW_HIDDEN" == false ]]; then
        find_cmd="$find_cmd -not -path '*/.*'"
    fi
    
    # Ajouter les filtres de taille
    if [[ -n "$MIN_SIZE" ]]; then
        local min_bytes=$(parse_size "$MIN_SIZE")
        find_cmd="$find_cmd -size +${min_bytes}c"
    fi
    
    if [[ -n "$MAX_SIZE" ]]; then
        local max_bytes=$(parse_size "$MAX_SIZE")
        find_cmd="$find_cmd -size -${max_bytes}c"
    fi
    
    # Ajouter le filtre de date
    if [[ -n "$MODIFIED_DAYS" ]]; then
        find_cmd="$find_cmd -mtime -$MODIFIED_DAYS"
    fi
    
    # Ajouter le pattern de nom
    if [[ "$REGEX_MODE" == true ]]; then
        find_cmd="$find_cmd -regex \".*$pattern.*\""
    elif [[ "$EXACT_MATCH" == true ]]; then
        # Recherche exacte du nom (sans extension pour les fichiers)
        if [[ "$CASE_SENSITIVE" == true ]]; then
            find_cmd="$find_cmd -name \"$pattern\""
        else
            find_cmd="$find_cmd -iname \"$pattern\""
        fi
    else
        # Recherche partielle (comportement par défaut)
        if [[ "$CASE_SENSITIVE" == true ]]; then
            find_cmd="$find_cmd -name \"*$pattern*\""
        else
            find_cmd="$find_cmd -iname \"*$pattern*\""
        fi
    fi
    
    # Exécuter la recherche
    eval "$find_cmd" 2>/dev/null | while IFS= read -r file; do
        # Nettoyer le nom de fichier et vérifier qu'il n'est pas vide
        file=$(echo "$file" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [[ -n "$file" && -e "$file" ]]; then
            display_result "$file"
        fi
    done
}

# Fonction pour afficher les résultats
display_result() {
    local file="$1"
    
    # Vérifier que le fichier existe et n'est pas vide
    if [[ -z "$file" || ! -e "$file" ]]; then
        return
    fi
    
    case $OUTPUT_FORMAT in
        simple)
            echo "$file"
            ;;
        json)
            local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
            local modified=$(stat -f%m "$file" 2>/dev/null || stat -c%Y "$file" 2>/dev/null || echo "0")
            local created=""
            if [[ "$OSTYPE" == "darwin"* ]]; then
                created=$(stat -f%B "$file" 2>/dev/null || echo "0")
            else
                created=$(stat -c%W "$file" 2>/dev/null || echo "0")
            fi
            local type="file"
            if [[ -d "$file" ]]; then
                type="directory"
            fi
            echo "{\"path\":\"$file\",\"type\":\"$type\",\"size\":$size,\"modified\":$modified,\"created\":$created}"
            ;;
        detailed|*)
            local size=""
            local modified=""
            local created=""
            local type=""
            
            if [[ -d "$file" ]]; then
                type="${BLUE}[DIR]${NC}"
                # Pour les dossiers, utiliser du -sh mais limiter la profondeur
                size=$(du -sh "$file" 2>/dev/null | cut -f1 | head -1 || echo "?")
            else
                type="${GREEN}[FILE]${NC}"
                # Pour les fichiers, utiliser ls -lh
                size=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' | head -1 || echo "?")
            fi
            
            # Obtenir la date de modification
            if [[ -d "$file" ]]; then
                # Pour les dossiers, utiliser la date du dossier lui-même
                modified=$(ls -ld "$file" 2>/dev/null | awk '{print $6, $7, $8}' | head -1 || echo "?")
            else
                # Pour les fichiers, utiliser ls -l
                modified=$(ls -l "$file" 2>/dev/null | awk '{print $6, $7, $8}' | head -1 || echo "?")
            fi
            
            # Obtenir la date de création (birth time)
            if [[ "$OSTYPE" == "darwin"* ]]; then
                # Sur macOS, utiliser stat avec -f pour birth time
                created=$(stat -f "%SB" -t "%d %b %H:%M" "$file" 2>/dev/null || echo "?")
            else
                # Sur Linux, utiliser stat avec -c pour birth time
                created=$(stat -c "%w" "$file" 2>/dev/null | awk '{print $1, $2, $3}' | sed 's/^[0-9-]* //' || echo "?")
            fi
            
            # Si la date de création n'est pas disponible, utiliser la date de modification
            if [[ "$created" == "?" || -z "$created" ]]; then
                created="$modified"
            fi
            
            # Nettoyer les variables pour éviter les lignes vides
            size=$(echo "$size" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            modified=$(echo "$modified" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            created=$(echo "$created" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # S'assurer que nous avons des valeurs valides
            if [[ -z "$size" || "$size" == "?" ]]; then
                size="?"
            fi
            if [[ -z "$modified" || "$modified" == "?" ]]; then
                modified="?"
            fi
            if [[ -z "$created" || "$created" == "?" ]]; then
                created="?"
            fi
            
            # Afficher le résultat avec les deux dates
            printf "${WHITE}%-50s${NC} ${type} ${YELLOW}%8s${NC} ${PURPLE}Mod: %s${NC} ${CYAN}Créé: %s${NC}\n" "$file" "$size" "$modified" "$created"
            ;;
    esac
}

# Fonction pour rechercher dans le contenu des fichiers
search_content() {
    local pattern="$1"
    local search_dir="$2"
    
    local grep_cmd="grep -r"
    
    if [[ "$CASE_SENSITIVE" == false ]]; then
        grep_cmd="$grep_cmd -i"
    fi
    
    if [[ "$REGEX_MODE" == true ]]; then
        grep_cmd="$grep_cmd -E"
    else
        grep_cmd="$grep_cmd -F"
    fi
    
    if [[ "$SHOW_HIDDEN" == false ]]; then
        grep_cmd="$grep_cmd --exclude-dir='.*'"
    fi
    
    grep_cmd="$grep_cmd -n \"$pattern\" \"$search_dir\""
    
    echo -e "${CYAN}Recherche dans le contenu des fichiers:${NC}"
    eval "$grep_cmd" 2>/dev/null | while IFS=: read -r file line content; do
        printf "${GREEN}%s${NC}:${YELLOW}%s${NC}: %s\n" "$file" "$line" "$content"
    done
}

# Fonction du mode interactif
interactive_mode() {
    local current_dir="$1"
    local selected_index=0
    local current_page=0
    local items_per_page=20
    local items=()
    local item_types=()
    
    # Fonction pour obtenir les éléments du répertoire
    get_directory_items() {
        items=()
        item_types=()
        
        # Ajouter le répertoire parent si on n'est pas à la racine
        if [[ "$current_dir" != "/" ]]; then
            items+=("..")
            item_types+=("dir")
        fi
        
        # Utiliser ls simple pour la vitesse
        local ls_cmd="ls -1A \"$current_dir\""
        if [[ "$SHOW_HIDDEN" == false ]]; then
            ls_cmd="ls -1 \"$current_dir\""
        fi
        
        # Utiliser un fichier temporaire pour éviter les problèmes de sous-shell
        local temp_file=$(mktemp)
        eval "$ls_cmd" 2>/dev/null > "$temp_file"
        
        while IFS= read -r item; do
            if [[ -n "$item" ]]; then
                items+=("$item")
                if [[ -d "$current_dir/$item" ]]; then
                    item_types+=("dir")
                else
                    item_types+=("file")
                fi
            fi
        done < "$temp_file"
        
        rm -f "$temp_file"
    }
    
    # Fonction pour afficher l'interface
    display_interface() {
        clear
        echo -e "${WHITE}=== Mode Interactif - Search ===${NC}"
        echo -e "${CYAN}Répertoire:${NC} $(realpath "$current_dir")"
        echo -e "${CYAN}Fichiers cachés:${NC} $SHOW_HIDDEN"
        echo ""
        echo -e "${YELLOW}Contrôles:${NC}"
        echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
        echo -e "  ${GREEN}Entrée${NC} : Entrer dans le dossier / Ouvrir le fichier"
        echo -e "  ${GREEN}Backspace${NC} : Aller au répertoire parent"
        echo -e "  ${GREEN}/${NC} : Lancer une recherche"
        echo -e "  ${GREEN}m${NC} : Menu contextuel (renommer, supprimer, etc.)"
        echo -e "  ${GREEN}s${NC} : Sélectionner ce répertoire"
        echo -e "  ${GREEN}h${NC} : Basculer les fichiers cachés"
        echo -e "  ${GREEN}←/→${NC} : Page précédente/suivante"
        
        # Vérifier si c'est un repository Git
        if [[ -d "$current_dir/.git" ]]; then
            echo -e "  ${GREEN}g${NC} : Gérer le repository Git"
        fi
        
        echo -e "  ${GREEN}q${NC} : Quitter"
        echo ""
        
        # Calculer les indices de pagination
        local total_items=${#items[@]}
        local total_pages=$(( (total_items + items_per_page - 1) / items_per_page ))
        local start_index=$((current_page * items_per_page))
        local end_index=$((start_index + items_per_page - 1))
        
        # Ajuster l'index sélectionné si nécessaire
        if [[ $selected_index -ge $total_items ]]; then
            selected_index=$((total_items - 1))
        fi
        if [[ $selected_index -lt 0 ]]; then
            selected_index=0
        fi
        
        # Ajuster la page courante si nécessaire
        local selected_page=$((selected_index / items_per_page))
        if [[ $selected_page -ne $current_page ]]; then
            current_page=$selected_page
            start_index=$((current_page * items_per_page))
            end_index=$((start_index + items_per_page - 1))
        fi
        
        # Afficher les éléments de la page courante
        for ((i=start_index; i<=end_index && i<total_items; i++)); do
            local item="${items[$i]}"
            local type="${item_types[$i]}"
            local prefix="  "
            local color=""
            
            if [[ $i -eq $selected_index ]]; then
                prefix="> "
                color="${WHITE}"
            fi
            
            if [[ "$type" == "dir" ]]; then
                echo -e "${prefix}${color}${BLUE}[DIR]${NC} ${color}$item${NC}"
            else
                echo -e "${prefix}${color}${GREEN}[FILE]${NC} ${color}$item${NC}"
            fi
        done
        
        # Afficher les informations de pagination
        echo ""
        echo -e "${PURPLE}Page $((current_page + 1))/$total_pages - Élément $((selected_index + 1))/$total_items${NC}"
    }
    
    # Fonction de recherche dédiée au mode interactif
    search_interactive() {
        local pattern="$1"
        local search_dir="$2"
        local results=()
        local types=()
        local sizes=()
        local modified_dates=()
        local created_dates=()
        
        # Utiliser find directement pour la recherche (toujours insensible à la casse)
        local find_cmd="find \"$search_dir\" -maxdepth 1"
        
        # Ajouter les filtres selon les options
        if [[ "$SHOW_HIDDEN" == false ]]; then
            find_cmd="$find_cmd -not -path '*/.*'"
        fi
        
        # Ajouter le pattern de recherche (toujours insensible à la casse)
        if [[ "$EXACT_MATCH" == true ]]; then
            find_cmd="$find_cmd -iname \"$pattern\""
        else
            find_cmd="$find_cmd -iname \"*$pattern*\""
        fi
        
        # Exécuter la recherche et collecter les métadonnées
        while IFS= read -r -d '' file; do
            if [[ -d "$file" ]]; then
                results+=("$file")
                types+=("dir")
                # Taille du dossier
                local size=$(du -sh "$file" 2>/dev/null | cut -f1 | head -1 || echo "?")
                sizes+=("$size")
            else
                results+=("$file")
                types+=("file")
                # Taille du fichier
                local size=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' | head -1 || echo "?")
                sizes+=("$size")
            fi
            
            # Date de modification
            local modified=$(ls -l "$file" 2>/dev/null | awk '{print $6, $7, $8}' | head -1 || echo "?")
            modified_dates+=("$modified")
            
            # Date de création
            local created=""
            if [[ "$OSTYPE" == "darwin"* ]]; then
                created=$(stat -f "%SB" -t "%d %b %H:%M" "$file" 2>/dev/null || echo "?")
            else
                created=$(stat -c "%w" "$file" 2>/dev/null | awk '{print $1, $2, $3}' | sed 's/^[0-9-]* //' || echo "?")
            fi
            
            # Si la date de création n'est pas disponible, utiliser la date de modification
            if [[ "$created" == "?" || -z "$created" ]]; then
                created="$modified"
            fi
            created_dates+=("$created")
            
        done < <(eval "$find_cmd -print0" 2>/dev/null)
        
        # Retourner les résultats via des variables globales
        SEARCH_RESULTS=("${results[@]}")
        SEARCH_TYPES=("${types[@]}")
        SEARCH_SIZES=("${sizes[@]}")
        SEARCH_MODIFIED=("${modified_dates[@]}")
        SEARCH_CREATED=("${created_dates[@]}")
    }
    
    # Fonction pour le menu contextuel
    context_menu() {
        if [[ ${#items[@]} -eq 0 ]]; then
            echo -e "${RED}Aucun élément sélectionné${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        local selected_item="${items[$selected_index]}"
        local selected_type="${item_types[$selected_index]}"
        local selected_path="$current_dir/$selected_item"
        
        # Gérer le répertoire parent différemment
        if [[ "$selected_item" == ".." ]]; then
            # Définir les options limitées pour le répertoire parent
            local parent_options=("Afficher détails" "Créer un fichier" "Créer un dossier")
            local selected_option=0
            
            while true; do
                clear
                echo -e "${WHITE}=== Menu Contextuel - Répertoire Parent ===${NC}"
                echo -e "${CYAN}Élément:${NC} $selected_item"
                echo -e "${CYAN}Type:${NC} $selected_type"
                echo -e "${CYAN}Chemin:${NC} $selected_path"
                echo ""
                echo -e "${YELLOW}Actions disponibles:${NC}"
                echo ""
                
                # Afficher les options avec sélection
                for ((i=0; i<${#parent_options[@]}; i++)); do
                    local prefix="  "
                    local color=""
                    
                    if [[ $i -eq $selected_option ]]; then
                        prefix="> "
                        color="${WHITE}"
                    fi
                    
                    echo -e "${prefix}${color}${GREEN}[ACTION]${NC} ${color}${parent_options[$i]}${NC}"
                done
                
                echo ""
                echo -e "${YELLOW}Contrôles:${NC}"
                echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
                echo -e "  ${GREEN}Entrée${NC} : Sélectionner"
                echo -e "  ${GREEN}q${NC} : Retour"
                echo ""
                
                # Lire la touche
                read -rsn1 key
                
                case "$key" in
                    $'\e')  # Séquence d'échappement
                        read -rsn2 key
                        case "$key" in
                            '[A')  # Flèche haut
                                if [[ $selected_option -gt 0 ]]; then
                                    selected_option=$((selected_option - 1))
                                fi
                                ;;
                            '[B')  # Flèche bas
                                if [[ $selected_option -lt $((${#parent_options[@]} - 1)) ]]; then
                                    selected_option=$((selected_option + 1))
                                fi
                                ;;
                        esac
                        ;;
                    '')  # Entrée
                        local chosen_action="${parent_options[$selected_option]}"
                        
                        case "$chosen_action" in
                            "Afficher détails")
                                show_item_details "$selected_path" "$selected_type"
                                ;;
                            "Créer un fichier")
                                create_file "$current_dir"
                                ;;
                            "Créer un dossier")
                                create_directory "$current_dir"
                                ;;
                        esac
                        return
                        ;;
                    'q')  # Quitter
                        return
                        ;;
                esac
            done
        fi
        
        # Définir les options du menu selon le type d'élément
        local menu_options=("Afficher détails" "Renommer" "Supprimer" "Déplacer" "Copier")
        
        # Ajouter l'option SSH si disponible
        if command -v scp >/dev/null 2>&1 || command -v rsync >/dev/null 2>&1; then
            menu_options+=("Copier via SSH")
        fi
        
        # Ajouter les options de compression/décompression
        if [[ "$selected_type" == "dir" ]]; then
            menu_options+=("Zipper le dossier")
        elif [[ "$selected_type" == "file" ]]; then
            # Vérifier si c'est un fichier zip
            if [[ "$selected_item" == *.zip ]]; then
                menu_options+=("Dézipper le fichier")
            else
                menu_options+=("Zipper le fichier")
            fi
        fi
        
        menu_options+=("Créer un fichier" "Créer un dossier" "Statistiques et hash")
        local selected_option=0
        
        while true; do
            clear
            echo -e "${WHITE}=== Menu Contextuel ===${NC}"
            echo -e "${CYAN}Élément:${NC} $selected_item"
            echo -e "${CYAN}Type:${NC} $selected_type"
            echo -e "${CYAN}Chemin:${NC} $selected_path"
            echo ""
            echo -e "${YELLOW}Actions disponibles:${NC}"
            echo ""
            
            # Afficher les options avec sélection
            for ((i=0; i<${#menu_options[@]}; i++)); do
                local prefix="  "
                local color=""
                
                if [[ $i -eq $selected_option ]]; then
                    prefix="> "
                    color="${WHITE}"
                fi
                
                echo -e "${prefix}${color}${GREEN}[ACTION]${NC} ${color}${menu_options[$i]}${NC}"
            done
            
            echo ""
            echo -e "${YELLOW}Contrôles:${NC}"
            echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
            echo -e "  ${GREEN}Entrée${NC} : Sélectionner"
            echo -e "  ${GREEN}q${NC} : Retour"
            echo ""
            
            # Lire la touche
            read -rsn1 key
            
            case "$key" in
                $'\e')  # Séquence d'échappement
                    read -rsn2 key
                    case "$key" in
                        '[A')  # Flèche haut
                            if [[ $selected_option -gt 0 ]]; then
                                selected_option=$((selected_option - 1))
                            fi
                            ;;
                        '[B')  # Flèche bas
                            if [[ $selected_option -lt $((${#menu_options[@]} - 1)) ]]; then
                                selected_option=$((selected_option + 1))
                            fi
                            ;;
                    esac
                    ;;
                '')  # Entrée
                    local chosen_action="${menu_options[$selected_option]}"
                    
                    case "$chosen_action" in
                        "Afficher détails")
                            show_item_details "$selected_path" "$selected_type"
                            ;;
                        "Statistiques et hash")
                            show_item_statistics "$selected_path" "$selected_type"
                            ;;
                        "Copier")
                            copy_item "$selected_path" "$selected_item" "$selected_type"
                            ;;
                        "Copier via SSH")
                            copy_item_ssh "$selected_path" "$selected_item" "$selected_type"
                            ;;
                        "Renommer")
                            rename_item "$selected_path" "$selected_item"
                            ;;
                        "Déplacer")
                            move_item "$selected_path" "$selected_item" "$selected_type"
                            ;;
                        "Supprimer")
                            delete_item "$selected_path" "$selected_item" "$selected_type"
                            ;;
                        "Zipper le dossier")
                            zip_item "$selected_path" "$selected_item" "$selected_type"
                            ;;
                        "Zipper le fichier")
                            zip_item "$selected_path" "$selected_item" "$selected_type"
                            ;;
                        "Dézipper le fichier")
                            unzip_item "$selected_path" "$selected_item" "$selected_type"
                            ;;
                        "Créer un fichier")
                            create_file "$current_dir"
                            ;;
                        "Créer un dossier")
                            create_directory "$current_dir"
                            ;;
                    esac
                    return
                    ;;
                'q')  # Quitter
                    return
                    ;;
            esac
        done
    }
    
    # Fonction pour afficher les détails d'un élément (optimisée)
    show_item_details() {
        local item_path="$1"
        local item_type="$2"
        
        clear
        echo -e "${WHITE}=== Détails de l'élément ===${NC}"
        echo -e "${CYAN}Chemin:${NC} $item_path"
        echo -e "${CYAN}Type:${NC} $item_type"
        echo ""
        
        # Récupérer toutes les informations en une seule fois pour optimiser
        local ls_info=$(ls -ld "$item_path" 2>/dev/null)
        local stat_info=""
        
        # Utiliser stat une seule fois pour récupérer toutes les infos
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS - récupérer toutes les infos stat en une fois
            stat_info=$(stat -f"%SB|%Sm|%Sa|%Sc|%z|%i|%l|%b|%k|%u|%g" "$item_path" 2>/dev/null)
        else
            # Linux - récupérer toutes les infos stat en une fois
            stat_info=$(stat -c"%w|%y|%x|%z|%s|%i|%h|%b|%B|%u|%g" "$item_path" 2>/dev/null)
        fi
        
        # Informations de base
        echo -e "${YELLOW}=== Informations de base ===${NC}"
        echo -e "  ${GREEN}Nom:${NC} $(basename "$item_path")"
        echo -e "  ${GREEN}Chemin absolu:${NC} $(realpath "$item_path" 2>/dev/null || echo "$item_path")"
        echo -e "  ${GREEN}Chemin relatif:${NC} $(realpath --relative-to="$(pwd)" "$item_path" 2>/dev/null || echo "N/A")"
        
        # Informations de taille (optimisées)
        if [[ "$item_type" == "dir" ]]; then
            echo -e "  ${GREEN}Taille:${NC} $(du -sh "$item_path" 2>/dev/null | cut -f1)"
            # Compter les éléments plus rapidement
            local total_count=$(ls -1A "$item_path" 2>/dev/null | wc -l | tr -d ' ')
            local file_count=$(ls -1A "$item_path" 2>/dev/null | grep -v "^d" | wc -l | tr -d ' ')
            local dir_count=$((total_count - file_count))
            echo -e "  ${GREEN}Éléments totaux:${NC} $total_count fichiers/dossiers"
            echo -e "  ${GREEN}Fichiers:${NC} $file_count fichiers"
            echo -e "  ${GREEN}Dossiers:${NC} $dir_count dossiers"
        else
            if [[ -n "$ls_info" ]]; then
                local size=$(echo "$ls_info" | awk '{print $5}')
                echo -e "  ${GREEN}Taille:${NC} $size"
            fi
            if [[ -n "$stat_info" ]]; then
                local size_bytes=$(echo "$stat_info" | cut -d'|' -f5)
                echo -e "  ${GREEN}Taille en octets:${NC} $size_bytes octets"
            fi
            # Type MIME seulement si c'est un fichier
            local mime_type=$(file -b --mime-type "$item_path" 2>/dev/null || echo "N/A")
            echo -e "  ${GREEN}Type MIME:${NC} $mime_type"
        fi
        
        # Informations de dates (optimisées)
        echo ""
        echo -e "${YELLOW}=== Informations de dates ===${NC}"
        if [[ -n "$stat_info" ]]; then
            IFS='|' read -r created modified accessed changed size_bytes inode links blocks block_size uid gid <<< "$stat_info"
            echo -e "  ${GREEN}Créé:${NC} $created"
            echo -e "  ${GREEN}Modifié:${NC} $modified"
            echo -e "  ${GREEN}Accédé:${NC} $accessed"
            echo -e "  ${GREEN}Changé:${NC} $changed"
        elif [[ -n "$ls_info" ]]; then
            local date_info=$(echo "$ls_info" | awk '{print $6, $7, $8}')
            echo -e "  ${GREEN}Modifié:${NC} $date_info"
        fi
        
        # Informations de permissions et propriétaire (optimisées)
        echo ""
        echo -e "${YELLOW}=== Permissions et propriétaire ===${NC}"
        if [[ -n "$ls_info" ]]; then
            local perms=$(echo "$ls_info" | awk '{print $1}')
            local owner=$(echo "$ls_info" | awk '{print $3":"$4}')
            echo -e "  ${GREEN}Permissions:${NC} $perms"
            echo -e "  ${GREEN}Propriétaire:${NC} $owner"
            
            if [[ -n "$stat_info" ]]; then
                echo -e "  ${GREEN}UID:GID:${NC} $uid:$gid"
            fi
        fi
        
        # Informations système (optimisées)
        echo ""
        echo -e "${YELLOW}=== Informations système ===${NC}"
        if [[ -n "$stat_info" ]]; then
            echo -e "  ${GREEN}Inode:${NC} $inode"
            echo -e "  ${GREEN}Liens:${NC} $links"
            echo -e "  ${GREEN}Blocs:${NC} $blocks"
            echo -e "  ${GREEN}Taille de bloc:${NC} $block_size octets"
        fi
        
        # Informations spécifiques aux dossiers (optimisées)
        if [[ "$item_type" == "dir" ]]; then
            echo ""
            echo -e "${YELLOW}=== Informations du dossier ===${NC}"
            
            # Contenu du dossier (limité pour la performance)
            local dir_contents=$(ls -1A "$item_path" 2>/dev/null | head -10)
            if [[ -n "$dir_contents" ]]; then
                echo -e "  ${GREEN}Premiers éléments:${NC}"
                echo "$dir_contents" | while read -r item; do
                    if [[ -d "$item_path/$item" ]]; then
                        echo -e "    ${BLUE}[DIR]${NC} $item"
                    else
                        echo -e "    ${GREEN}[FILE]${NC} $item"
                    fi
                done
                local total_items=$(ls -1A "$item_path" 2>/dev/null | wc -l | tr -d ' ')
                if [[ $total_items -gt 10 ]]; then
                    echo -e "    ${PURPLE}... et $((total_items - 10)) autres éléments${NC}"
                fi
            fi
        fi
        
        echo ""
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour afficher les statistiques et hash d'un élément
    show_item_statistics() {
        local item_path="$1"
        local item_type="$2"
        
        clear
        echo -e "${WHITE}=== Statistiques et hash ===${NC}"
        echo -e "${CYAN}Élément:${NC} $(basename "$item_path")"
        echo -e "${CYAN}Chemin:${NC} $item_path"
        echo -e "${CYAN}Type:${NC} $item_type"
        echo ""
        
        # Statistiques du fichier (seulement pour les fichiers)
        if [[ "$item_type" == "file" ]]; then
            echo -e "${YELLOW}=== Statistiques du fichier ===${NC}"
            
            # Lignes et caractères
            if [[ -r "$item_path" ]]; then
                echo -e "  ${GREEN}Lignes:${NC} $(wc -l < "$item_path" 2>/dev/null || echo "N/A")"
                echo -e "  ${GREEN}Mots:${NC} $(wc -w < "$item_path" 2>/dev/null || echo "N/A")"
                echo -e "  ${GREEN}Caractères:${NC} $(wc -c < "$item_path" 2>/dev/null || echo "N/A")"
                echo -e "  ${GREEN}Caractères (sans espaces):${NC} $(wc -m < "$item_path" 2>/dev/null || echo "N/A")"
            fi
            
            echo ""
            echo -e "${YELLOW}=== Hash du fichier ===${NC}"
            
            # Hash du fichier
            if command -v md5sum >/dev/null 2>&1; then
                echo -e "  ${GREEN}MD5:${NC} $(md5sum "$item_path" 2>/dev/null | cut -d' ' -f1 || echo "N/A")"
            elif command -v md5 >/dev/null 2>&1; then
                echo -e "  ${GREEN}MD5:${NC} $(md5 -q "$item_path" 2>/dev/null || echo "N/A")"
            fi
            
            if command -v sha256sum >/dev/null 2>&1; then
                echo -e "  ${GREEN}SHA256:${NC} $(sha256sum "$item_path" 2>/dev/null | cut -d' ' -f1 || echo "N/A")"
            elif command -v shasum >/dev/null 2>&1; then
                echo -e "  ${GREEN}SHA256:${NC} $(shasum -a 256 "$item_path" 2>/dev/null | cut -d' ' -f1 || echo "N/A")"
            fi
            
            # Encodage (si disponible)
            if command -v file >/dev/null 2>&1; then
                local encoding=$(file -b --mime-encoding "$item_path" 2>/dev/null)
                if [[ -n "$encoding" && "$encoding" != "binary" ]]; then
                    echo -e "  ${GREEN}Encodage:${NC} $encoding"
                fi
            fi
        else
            echo -e "${YELLOW}=== Statistiques du dossier ===${NC}"
            echo -e "  ${GREEN}Éléments totaux:${NC} $(find "$item_path" -maxdepth 1 | wc -l | tr -d ' ') fichiers/dossiers"
            echo -e "  ${GREEN}Fichiers:${NC} $(find "$item_path" -maxdepth 1 -type f | wc -l | tr -d ' ') fichiers"
            echo -e "  ${GREEN}Dossiers:${NC} $(find "$item_path" -maxdepth 1 -type d | wc -l | tr -d ' ') dossiers"
            echo -e "  ${GREEN}Taille totale:${NC} $(du -sh "$item_path" 2>/dev/null | cut -f1)"
        fi
        
        echo ""
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour renommer un élément
    rename_item() {
        local item_path="$1"
        local current_name="$2"
        
        clear
        echo -e "${WHITE}=== Renommer ===${NC}"
        echo -e "${CYAN}Élément actuel:${NC} $current_name"
        echo -e "${CYAN}Chemin:${NC} $item_path"
        echo ""
        echo -e "${CYAN}Nouveau nom:${NC} "
        read -r new_name
        
        if [[ -n "$new_name" && "$new_name" != "$current_name" ]]; then
            local new_path="$current_dir/$new_name"
            if [[ -e "$new_path" ]]; then
                echo -e "${RED}Erreur: Un élément avec ce nom existe déjà${NC}"
            else
                if mv "$item_path" "$new_path" 2>/dev/null; then
                    echo -e "${GREEN}Élément renommé avec succès${NC}"
                else
                    echo -e "${RED}Erreur lors du renommage${NC}"
                fi
            fi
        else
            echo -e "${YELLOW}Renommage annulé${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour supprimer un élément
    delete_item() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        clear
        echo -e "${WHITE}=== Supprimer ===${NC}"
        echo -e "${CYAN}Élément:${NC} $item_name"
        echo -e "${CYAN}Type:${NC} $item_type"
        echo -e "${CYAN}Chemin:${NC} $item_path"
        echo ""
        echo -e "${RED}ATTENTION: Cette action est irréversible !${NC}"
        echo ""
        echo -e "${CYAN}Êtes-vous sûr de vouloir supprimer cet élément ? (y/n):${NC} "
        read -r confirmation
        
        if [[ "$confirmation" == "y" || "$confirmation" == "n" ]]; then
            if [[ "$item_type" == "dir" ]]; then
                if rm -rf "$item_path" 2>/dev/null; then
                    echo -e "${GREEN}Dossier supprimé avec succès${NC}"
                else
                    echo -e "${RED}Erreur lors de la suppression du dossier${NC}"
                fi
            else
                if rm "$item_path" 2>/dev/null; then
                    echo -e "${GREEN}Fichier supprimé avec succès${NC}"
                else
                    echo -e "${RED}Erreur lors de la suppression du fichier${NC}"
                fi
            fi
        else
            echo -e "${YELLOW}Suppression annulée${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour déplacer un élément
    move_item() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        # Définir les options du menu
        local move_options=("Saisir le chemin manuellement" "Naviguer pour sélectionner")
        local selected_option=0
        
        while true; do
            clear
            echo -e "${WHITE}=== Déplacer ===${NC}"
            echo -e "${CYAN}Élément:${NC} $item_name"
            echo -e "${CYAN}Type:${NC} $item_type"
            echo -e "${CYAN}Chemin actuel:${NC} $item_path"
            echo ""
            echo -e "${YELLOW}Choisissez la méthode de sélection:${NC}"
            echo ""
            
            # Afficher les options avec sélection
            for ((i=0; i<${#move_options[@]}; i++)); do
                local prefix="  "
                local color=""
                
                if [[ $i -eq $selected_option ]]; then
                    prefix="> "
                    color="${WHITE}"
                fi
                
                echo -e "${prefix}${color}${GREEN}[OPTION]${NC} ${color}${move_options[$i]}${NC}"
            done
            
            echo ""
            echo -e "${YELLOW}Contrôles:${NC}"
            echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
            echo -e "  ${GREEN}Entrée${NC} : Sélectionner"
            echo -e "  ${GREEN}q${NC} : Annuler"
            echo ""
            
            # Lire la touche
            read -rsn1 key
            
            case "$key" in
                $'\e')  # Séquence d'échappement
                    read -rsn2 key
                    case "$key" in
                        '[A')  # Flèche haut
                            if [[ $selected_option -gt 0 ]]; then
                                selected_option=$((selected_option - 1))
                            fi
                            ;;
                        '[B')  # Flèche bas
                            if [[ $selected_option -lt $((${#move_options[@]} - 1)) ]]; then
                                selected_option=$((selected_option + 1))
                            fi
                            ;;
                    esac
                    ;;
                '')  # Entrée
                    local chosen_option="${move_options[$selected_option]}"
                    
                    case "$chosen_option" in
                        "Saisir le chemin manuellement")
                            move_item_manual "$item_path" "$item_name" "$item_type"
                            return
                            ;;
                        "Naviguer pour sélectionner")
                            move_item_navigate "$item_path" "$item_name" "$item_type"
                            return
                            ;;
                    esac
                    ;;
                'q')  # Quitter
                    echo -e "${YELLOW}Déplacement annulé${NC}"
                    echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                    read
                    return
                    ;;
            esac
        done
    }
    
    # Fonction pour déplacer avec saisie manuelle
    move_item_manual() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        clear
        echo -e "${WHITE}=== Déplacer - Saisie manuelle ===${NC}"
        echo -e "${CYAN}Élément:${NC} $item_name"
        echo -e "${CYAN}Chemin actuel:${NC} $item_path"
        echo ""
        echo -e "${CYAN}Chemin de destination:${NC} "
        read -r dest_path
        
        if [[ -n "$dest_path" ]]; then
            # Convertir le chemin relatif en absolu si nécessaire
            if [[ "$dest_path" != /* ]]; then
                dest_path="$current_dir/$dest_path"
            fi
            
            if [[ -d "$dest_path" ]]; then
                local dest_file="$dest_path/$item_name"
                if [[ -e "$dest_file" ]]; then
                    echo -e "${RED}Erreur: Un élément avec ce nom existe déjà dans la destination${NC}"
                else
                    if mv "$item_path" "$dest_path/" 2>/dev/null; then
                        echo -e "${GREEN}Élément déplacé avec succès vers $dest_path${NC}"
                    else
                        echo -e "${RED}Erreur lors du déplacement${NC}"
                    fi
                fi
            else
                echo -e "${RED}Erreur: Le répertoire de destination n'existe pas${NC}"
            fi
        else
            echo -e "${YELLOW}Déplacement annulé${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour déplacer avec navigation
    move_item_navigate() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        local dest_dir="$current_dir"
        local dest_index=0
        local dest_page=0
        local dest_items_per_page=20
        local dest_items=()
        local dest_item_types=()
        
        # Fonction pour obtenir les éléments du répertoire de destination
        get_dest_items() {
            dest_items=()
            dest_item_types=()
            
            # Ajouter le répertoire parent si on n'est pas à la racine
            if [[ "$dest_dir" != "/" ]]; then
                dest_items+=("..")
                dest_item_types+=("dir")
            fi
            
            # Utiliser ls simple pour la vitesse
            local ls_cmd="ls -1A \"$dest_dir\""
            if [[ "$SHOW_HIDDEN" == false ]]; then
                ls_cmd="ls -1 \"$dest_dir\""
            fi
            
            # Utiliser un fichier temporaire pour éviter les problèmes de sous-shell
            local temp_file=$(mktemp)
            eval "$ls_cmd" 2>/dev/null > "$temp_file"
            
            while IFS= read -r item; do
                if [[ -n "$item" ]]; then
                    dest_items+=("$item")
                    if [[ -d "$dest_dir/$item" ]]; then
                        dest_item_types+=("dir")
                    else
                        dest_item_types+=("file")
                    fi
                fi
            done < "$temp_file"
            
            rm -f "$temp_file"
        }
        
        while true; do
            get_dest_items
            clear
            echo -e "${WHITE}=== Déplacer - Navigation ===${NC}"
            echo -e "${CYAN}Élément à déplacer:${NC} $item_name"
            echo -e "${CYAN}Répertoire de destination:${NC} $(realpath "$dest_dir")"
            echo ""
            echo -e "${YELLOW}Contrôles:${NC}"
            echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
            echo -e "  ${GREEN}Entrée${NC} : Entrer dans le dossier"
            echo -e "  ${GREEN}c${NC} : Confirmer ce répertoire"
            echo -e "  ${GREEN}←/→${NC} : Page précédente/suivante"
            echo -e "  ${GREEN}q${NC} : Annuler"
            echo ""
            
            # Calculer les indices de pagination
            local total_items=${#dest_items[@]}
            local total_pages=$(( (total_items + dest_items_per_page - 1) / dest_items_per_page ))
            local start_index=$((dest_page * dest_items_per_page))
            local end_index=$((start_index + dest_items_per_page - 1))
            
            # Ajuster l'index sélectionné si nécessaire
            if [[ $dest_index -ge $total_items ]]; then
                dest_index=$((total_items - 1))
            fi
            if [[ $dest_index -lt 0 ]]; then
                dest_index=0
            fi
            
            # Ajuster la page courante si nécessaire
            local selected_page=$((dest_index / dest_items_per_page))
            if [[ $selected_page -ne $dest_page ]]; then
                dest_page=$selected_page
                start_index=$((dest_page * dest_items_per_page))
                end_index=$((start_index + dest_items_per_page - 1))
            fi
            
            # Afficher les éléments de la page courante
            for ((i=start_index; i<=end_index && i<total_items; i++)); do
                local item="${dest_items[$i]}"
                local type="${dest_item_types[$i]}"
                local prefix="  "
                local color=""
                
                if [[ $i -eq $dest_index ]]; then
                    prefix="> "
                    color="${WHITE}"
                fi
                
                if [[ "$type" == "dir" ]]; then
                    echo -e "${prefix}${color}${BLUE}[DIR]${NC} ${color}$item${NC}"
                else
                    echo -e "${prefix}${color}${GREEN}[FILE]${NC} ${color}$item${NC}"
                fi
            done
            
            # Afficher les informations de pagination
            echo ""
            echo -e "${PURPLE}Page $((dest_page + 1))/$total_pages - Élément $((dest_index + 1))/$total_items${NC}"
            
            # Lire la touche
            read -rsn1 key
            
            case "$key" in
                $'\x1b')  # Séquence d'échappement (flèches)
                    read -rsn2 key
                    case "$key" in
                        '[A')  # Flèche haut
                            if [[ $dest_index -gt 0 ]]; then
                                dest_index=$((dest_index - 1))
                            fi
                            ;;
                        '[B')  # Flèche bas
                            if [[ $dest_index -lt $((total_items - 1)) ]]; then
                                dest_index=$((dest_index + 1))
                            fi
                            ;;
                        '[C')  # Flèche droite (page suivante)
                            if [[ $dest_page -lt $((total_pages - 1)) ]]; then
                                dest_page=$((dest_page + 1))
                                dest_index=$((dest_page * dest_items_per_page))
                            fi
                            ;;
                        '[D')  # Flèche gauche (page précédente)
                            if [[ $dest_page -gt 0 ]]; then
                                dest_page=$((dest_page - 1))
                                dest_index=$((dest_page * dest_items_per_page))
                            fi
                            ;;
                    esac
                    ;;
                '')  # Entrée
                    if [[ ${#dest_items[@]} -gt 0 ]]; then
                        local selected_item="${dest_items[$dest_index]}"
                        local selected_type="${dest_item_types[$dest_index]}"
                        
                        if [[ "$selected_type" == "dir" ]]; then
                            if [[ "$selected_item" == ".." ]]; then
                                # Navigation vers le répertoire parent
                                if [[ "$dest_dir" == "/" ]]; then
                                    # On est déjà à la racine, ne rien faire
                                    continue
                                else
                                    # Obtenir le répertoire parent de manière plus robuste
                                    if [[ "$dest_dir" == *"/"* ]]; then
                                        # Enlever le dernier segment du chemin
                                        dest_dir="${dest_dir%/*}"
                                        # S'assurer qu'on ne va pas en dessous de la racine
                                        if [[ -z "$dest_dir" ]]; then
                                            dest_dir="/"
                                        fi
                                    else
                                        dest_dir="/"
                                    fi
                                fi
                                dest_index=0
                                dest_page=0
                            else
                                # Entrer dans le dossier
                                if [[ "$dest_dir" == "/" ]]; then
                                    dest_dir="/$selected_item"
                                else
                                    dest_dir="$dest_dir/$selected_item"
                                fi
                                dest_index=0
                                dest_page=0
                            fi
                        else
                            echo -e "${RED}Erreur: Vous devez sélectionner un répertoire${NC}"
                            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                            read
                        fi
                    fi
                    ;;
                'c')  # Confirmer le déplacement
                    # Effectuer le déplacement vers le répertoire courant
                    local dest_file="$dest_dir/$item_name"
                    if [[ -e "$dest_file" ]]; then
                        echo -e "${RED}Erreur: Un élément avec ce nom existe déjà dans la destination${NC}"
                        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                        read
                    else
                        if mv "$item_path" "$dest_dir/" 2>/dev/null; then
                            echo -e "${GREEN}Élément déplacé avec succès vers $dest_dir${NC}"
                        else
                            echo -e "${RED}Erreur lors du déplacement${NC}"
                        fi
                        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                        read
                        return
                    fi
                    ;;
                'q')  # Quitter
                    echo -e "${YELLOW}Déplacement annulé${NC}"
                    echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                    read
                    return
                    ;;
            esac
        done
    }
    
    # Fonction pour copier un élément
    copy_item() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        # Définir les options du menu de copie
        local copy_options=("Dupliquer" "Naviguer" "Spécifier le chemin")
        local selected_option=0
        
        while true; do
            clear
            echo -e "${WHITE}=== Copier ===${NC}"
            echo -e "${CYAN}Élément:${NC} $item_name"
            echo -e "${CYAN}Type:${NC} $item_type"
            echo -e "${CYAN}Chemin:${NC} $item_path"
            echo ""
            echo -e "${YELLOW}Choisissez la méthode de copie:${NC}"
            echo ""
            
            # Afficher les options avec sélection
            for ((i=0; i<${#copy_options[@]}; i++)); do
                local prefix="  "
                local color=""
                
                if [[ $i -eq $selected_option ]]; then
                    prefix="> "
                    color="${WHITE}"
                fi
                
                echo -e "${prefix}${color}${GREEN}[COPY]${NC} ${color}${copy_options[$i]}${NC}"
            done
            
            echo ""
            echo -e "${YELLOW}Contrôles:${NC}"
            echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
            echo -e "  ${GREEN}Entrée${NC} : Sélectionner"
            echo -e "  ${GREEN}q${NC} : Annuler"
            echo ""
            
            # Lire la touche
            read -rsn1 key
            
            case "$key" in
                $'\e')  # Séquence d'échappement
                    read -rsn2 key
                    case "$key" in
                        '[A')  # Flèche haut
                            if [[ $selected_option -gt 0 ]]; then
                                selected_option=$((selected_option - 1))
                            fi
                            ;;
                        '[B')  # Flèche bas
                            if [[ $selected_option -lt $((${#copy_options[@]} - 1)) ]]; then
                                selected_option=$((selected_option + 1))
                            fi
                            ;;
                    esac
                    ;;
                '')  # Entrée
                    local chosen_option="${copy_options[$selected_option]}"
                    
                    case "$chosen_option" in
                        "Dupliquer")
                            copy_item_duplicate "$item_path" "$item_name" "$item_type"
                            return
                            ;;
                        "Naviguer")
                            copy_item_navigate "$item_path" "$item_name" "$item_type"
                            return
                            ;;
                        "Spécifier le chemin")
                            copy_item_manual "$item_path" "$item_name" "$item_type"
                            return
                            ;;
                    esac
                    ;;
                'q')  # Quitter
                    return
                    ;;
            esac
        done
    }
    
    # Fonction pour dupliquer un élément
    copy_item_duplicate() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        clear
        echo -e "${WHITE}=== Dupliquer ===${NC}"
        echo -e "${CYAN}Élément:${NC} $item_name"
        echo -e "${CYAN}Type:${NC} $item_type"
        echo -e "${CYAN}Chemin:${NC} $item_path"
        echo ""
        
        # Demander le nom de la copie
        local copy_name="${item_name%.*}_copy"
        if [[ "$item_type" == "file" && "$item_name" == *.* ]]; then
            local extension="${item_name##*.}"
            copy_name="${item_name%.*}_copy.$extension"
        elif [[ "$item_type" == "dir" ]]; then
            copy_name="${item_name}_copy"
        fi
        
        echo -e "${CYAN}Nom de la copie (défaut: $copy_name):${NC} "
        read -r custom_copy_name
        
        if [[ -n "$custom_copy_name" ]]; then
            copy_name="$custom_copy_name"
        fi
        
        local copy_path="$current_dir/$copy_name"
        
        # Vérifier si l'élément existe déjà
        if [[ -e "$copy_path" ]]; then
            echo -e "${RED}Erreur: Un élément avec ce nom existe déjà${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        echo -e "${YELLOW}Copie en cours...${NC}"
        
        # Effectuer la copie
        if [[ "$item_type" == "dir" ]]; then
            if cp -r "$item_path" "$copy_path" 2>/dev/null; then
                echo -e "${GREEN}Dossier dupliqué avec succès: $copy_name${NC}"
            else
                echo -e "${RED}Erreur lors de la duplication du dossier${NC}"
            fi
        else
            if cp "$item_path" "$copy_path" 2>/dev/null; then
                echo -e "${GREEN}Fichier dupliqué avec succès: $copy_name${NC}"
            else
                echo -e "${RED}Erreur lors de la duplication du fichier${NC}"
            fi
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour copier avec navigation
    copy_item_navigate() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        local dest_dir="$current_dir"
        local dest_index=0
        local dest_page=0
        local dest_items_per_page=20
        local dest_items=()
        local dest_item_types=()
        
        # Fonction pour obtenir les éléments du répertoire de destination
        get_dest_items() {
            dest_items=()
            dest_item_types=()
            
            # Ajouter le répertoire parent si on n'est pas à la racine
            if [[ "$dest_dir" != "/" ]]; then
                dest_items+=("..")
                dest_item_types+=("dir")
            fi
            
            # Utiliser ls simple pour la vitesse
            local ls_cmd="ls -1A \"$dest_dir\""
            if [[ "$SHOW_HIDDEN" == false ]]; then
                ls_cmd="ls -1 \"$dest_dir\""
            fi
            
            # Utiliser un fichier temporaire pour éviter les problèmes de sous-shell
            local temp_file=$(mktemp)
            eval "$ls_cmd" 2>/dev/null > "$temp_file"
            
            while IFS= read -r item; do
                if [[ -n "$item" ]]; then
                    dest_items+=("$item")
                    if [[ -d "$dest_dir/$item" ]]; then
                        dest_item_types+=("dir")
                    else
                        dest_item_types+=("file")
                    fi
                fi
            done < "$temp_file"
            
            rm -f "$temp_file"
        }
        
        while true; do
            get_dest_items
            clear
            echo -e "${WHITE}=== Copier - Navigation ===${NC}"
            echo -e "${CYAN}Élément à copier:${NC} $item_name"
            echo -e "${CYAN}Répertoire de destination:${NC} $(realpath "$dest_dir")"
            echo ""
            echo -e "${YELLOW}Contrôles:${NC}"
            echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
            echo -e "  ${GREEN}Entrée${NC} : Entrer dans le dossier"
            echo -e "  ${GREEN}c${NC} : Copier ici"
            echo -e "  ${GREEN}←/→${NC} : Page précédente/suivante"
            echo -e "  ${GREEN}q${NC} : Annuler"
            echo ""
            
            # Calculer les indices de pagination
            local total_items=${#dest_items[@]}
            local total_pages=$(( (total_items + dest_items_per_page - 1) / dest_items_per_page ))
            local start_index=$((dest_page * dest_items_per_page))
            local end_index=$((start_index + dest_items_per_page - 1))
            
            # Ajuster l'index sélectionné si nécessaire
            if [[ $dest_index -ge $total_items ]]; then
                dest_index=$((total_items - 1))
            fi
            if [[ $dest_index -lt 0 ]]; then
                dest_index=0
            fi
            
            # Ajuster la page courante si nécessaire
            local selected_page=$((dest_index / dest_items_per_page))
            if [[ $selected_page -ne $dest_page ]]; then
                dest_page=$selected_page
                start_index=$((dest_page * dest_items_per_page))
                end_index=$((start_index + dest_items_per_page - 1))
            fi
            
            # Afficher les éléments de la page courante
            for ((i=start_index; i<=end_index && i<total_items; i++)); do
                local item="${dest_items[$i]}"
                local type="${dest_item_types[$i]}"
                local prefix="  "
                local color=""
                
                if [[ $i -eq $dest_index ]]; then
                    prefix="> "
                    color="${WHITE}"
                fi
                
                if [[ "$type" == "dir" ]]; then
                    echo -e "${prefix}${color}${BLUE}[DIR]${NC} ${color}$item${NC}"
                else
                    echo -e "${prefix}${color}${GREEN}[FILE]${NC} ${color}$item${NC}"
                fi
            done
            
            # Afficher les informations de pagination
            echo ""
            echo -e "${PURPLE}Page $((dest_page + 1))/$total_pages - Élément $((dest_index + 1))/$total_items${NC}"
            
            # Lire la touche
            read -rsn1 key
            
            case "$key" in
                $'\x1b')  # Séquence d'échappement (flèches)
                    read -rsn2 key
                    case "$key" in
                        '[A')  # Flèche haut
                            if [[ $dest_index -gt 0 ]]; then
                                dest_index=$((dest_index - 1))
                            fi
                            ;;
                        '[B')  # Flèche bas
                            if [[ $dest_index -lt $((total_items - 1)) ]]; then
                                dest_index=$((dest_index + 1))
                            fi
                            ;;
                        '[C')  # Flèche droite (page suivante)
                            if [[ $dest_page -lt $((total_pages - 1)) ]]; then
                                dest_page=$((dest_page + 1))
                                dest_index=$((dest_page * dest_items_per_page))
                            fi
                            ;;
                        '[D')  # Flèche gauche (page précédente)
                            if [[ $dest_page -gt 0 ]]; then
                                dest_page=$((dest_page - 1))
                                dest_index=$((dest_page * dest_items_per_page))
                            fi
                            ;;
                    esac
                    ;;
                '')  # Entrée
                    if [[ ${#dest_items[@]} -gt 0 ]]; then
                        local selected_item="${dest_items[$dest_index]}"
                        local selected_type="${dest_item_types[$dest_index]}"
                        
                        if [[ "$selected_type" == "dir" ]]; then
                            if [[ "$selected_item" == ".." ]]; then
                                # Navigation vers le répertoire parent
                                if [[ "$dest_dir" == "/" ]]; then
                                    # On est déjà à la racine, ne rien faire
                                    continue
                                else
                                    # Obtenir le répertoire parent de manière plus robuste
                                    if [[ "$dest_dir" == *"/"* ]]; then
                                        # Enlever le dernier segment du chemin
                                        dest_dir="${dest_dir%/*}"
                                        # S'assurer qu'on ne va pas en dessous de la racine
                                        if [[ -z "$dest_dir" ]]; then
                                            dest_dir="/"
                                        fi
                                    else
                                        dest_dir="/"
                                    fi
                                fi
                                dest_index=0
                                dest_page=0
                            else
                                # Entrer dans le dossier
                                if [[ "$dest_dir" == "/" ]]; then
                                    dest_dir="/$selected_item"
                                else
                                    dest_dir="$dest_dir/$selected_item"
                                fi
                                dest_index=0
                                dest_page=0
                            fi
                        else
                            echo -e "${RED}Erreur: Vous devez sélectionner un répertoire${NC}"
                            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                            read
                        fi
                    fi
                    ;;
                'c')  # Copier ici
                    # Effectuer la copie vers le répertoire courant
                    local dest_file="$dest_dir/$item_name"
                    if [[ -e "$dest_file" ]]; then
                        echo -e "${RED}Erreur: Un élément avec ce nom existe déjà dans la destination${NC}"
                        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                        read
                    else
                        echo -e "${YELLOW}Copie en cours...${NC}"
                        if [[ "$item_type" == "dir" ]]; then
                            if cp -r "$item_path" "$dest_dir/" 2>/dev/null; then
                                echo -e "${GREEN}Dossier copié avec succès vers $dest_dir${NC}"
                            else
                                echo -e "${RED}Erreur lors de la copie du dossier${NC}"
                            fi
                        else
                            if cp "$item_path" "$dest_dir/" 2>/dev/null; then
                                echo -e "${GREEN}Fichier copié avec succès vers $dest_dir${NC}"
                            else
                                echo -e "${RED}Erreur lors de la copie du fichier${NC}"
                            fi
                        fi
                        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                        read
                        return
                    fi
                    ;;
                'q')  # Quitter
                    echo -e "${YELLOW}Copie annulée${NC}"
                    echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                    read
                    return
                    ;;
            esac
        done
    }
    
    # Fonction pour copier avec saisie manuelle
    copy_item_manual() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        clear
        echo -e "${WHITE}=== Copier - Saisie manuelle ===${NC}"
        echo -e "${CYAN}Élément:${NC} $item_name"
        echo -e "${CYAN}Type:${NC} $item_type"
        echo -e "${CYAN}Chemin actuel:${NC} $item_path"
        echo ""
        echo -e "${CYAN}Chemin de destination:${NC} "
        read -r dest_path
        
        if [[ -n "$dest_path" ]]; then
            # Convertir le chemin relatif en absolu si nécessaire
            if [[ "$dest_path" != /* ]]; then
                dest_path="$current_dir/$dest_path"
            fi
            
            if [[ -d "$dest_path" ]]; then
                local dest_file="$dest_path/$item_name"
                if [[ -e "$dest_file" ]]; then
                    echo -e "${RED}Erreur: Un élément avec ce nom existe déjà dans la destination${NC}"
                else
                    echo -e "${YELLOW}Copie en cours...${NC}"
                    if [[ "$item_type" == "dir" ]]; then
                        if cp -r "$item_path" "$dest_path/" 2>/dev/null; then
                            echo -e "${GREEN}Dossier copié avec succès vers $dest_path${NC}"
                        else
                            echo -e "${RED}Erreur lors de la copie du dossier${NC}"
                        fi
                    else
                        if cp "$item_path" "$dest_path/" 2>/dev/null; then
                            echo -e "${GREEN}Fichier copié avec succès vers $dest_path${NC}"
                        else
                            echo -e "${RED}Erreur lors de la copie du fichier${NC}"
                        fi
                    fi
                fi
            else
                echo -e "${RED}Erreur: Le répertoire de destination n'existe pas${NC}"
            fi
        else
            echo -e "${YELLOW}Copie annulée${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour copier via SSH
    copy_item_ssh() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        # Vérifier si les outils SSH sont disponibles
        if ! command -v scp >/dev/null 2>&1 && ! command -v rsync >/dev/null 2>&1; then
            echo -e "${RED}Erreur: Aucun outil SSH (scp/rsync) n'est disponible${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        # Définir les options du menu SSH
        local ssh_options=("Vers machine distante" "Depuis machine distante" "Générer commande SCP" "Gérer les connexions SSH")
        local selected_option=0
        
        while true; do
            clear
            echo -e "${WHITE}=== Copie SSH ===${NC}"
            echo -e "${CYAN}Élément:${NC} $item_name"
            echo -e "${CYAN}Type:${NC} $item_type"
            echo -e "${CYAN}Chemin:${NC} $item_path"
            echo ""
            echo -e "${YELLOW}Choisissez l'opération:${NC}"
            echo ""
            
            # Afficher les options avec sélection
            for ((i=0; i<${#ssh_options[@]}; i++)); do
                local prefix="  "
                local color=""
                
                if [[ $i -eq $selected_option ]]; then
                    prefix="> "
                    color="${WHITE}"
                fi
                
                echo -e "${prefix}${color}${GREEN}[SSH]${NC} ${color}${ssh_options[$i]}${NC}"
            done
            
            echo ""
            echo -e "${YELLOW}Contrôles:${NC}"
            echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
            echo -e "  ${GREEN}Entrée${NC} : Sélectionner"
            echo -e "  ${GREEN}q${NC} : Annuler"
            echo ""
            
            # Lire la touche
            read -rsn1 key
            
            case "$key" in
                $'\e')  # Séquence d'échappement
                    read -rsn2 key
                    case "$key" in
                        '[A')  # Flèche haut
                            if [[ $selected_option -gt 0 ]]; then
                                selected_option=$((selected_option - 1))
                            fi
                            ;;
                        '[B')  # Flèche bas
                            if [[ $selected_option -lt $((${#ssh_options[@]} - 1)) ]]; then
                                selected_option=$((selected_option + 1))
                            fi
                            ;;
                    esac
                    ;;
                '')  # Entrée
                    local chosen_option="${ssh_options[$selected_option]}"
                    
                    case "$chosen_option" in
                        "Vers machine distante")
                            ssh_copy_to_remote "$item_path" "$item_name" "$item_type"
                            return
                            ;;
                        "Depuis machine distante")
                            ssh_copy_from_remote "$item_path" "$item_name" "$item_type"
                            return
                            ;;
                        "Générer commande SCP")
                            ssh_generate_scp_command "$item_path" "$item_name" "$item_type"
                            return
                            ;;
                        "Gérer les connexions SSH")
                            ssh_manage_connections
                            ;;
                    esac
                    ;;
                'q')  # Quitter
                    return
                    ;;
            esac
        done
    }
    
    # Fonction pour copier vers une machine distante
    ssh_copy_to_remote() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        # Charger les connexions SSH configurées
        local ssh_connections=()
        local ssh_config_file="$HOME/.ssh/config"
        
        if [[ -f "$ssh_config_file" ]]; then
            while IFS= read -r line; do
                if [[ "$line" =~ ^Host[[:space:]]+([^#*[:space:]]+) ]]; then
                    local host_name="${BASH_REMATCH[1]}"
                    if [[ "$host_name" != "*" ]]; then
                        ssh_connections+=("$host_name")
                    fi
                fi
            done < "$ssh_config_file"
        fi
        
        # Si des connexions SSH sont configurées, permettre la navigation
        if [[ ${#ssh_connections[@]} -gt 0 ]]; then
            local selected_ssh_index=0
            
            while true; do
                clear
                echo -e "${WHITE}=== Copie vers machine distante ===${NC}"
                echo -e "${CYAN}Élément:${NC} $item_name"
                echo -e "${CYAN}Type:${NC} $item_type"
                echo ""
                echo -e "${YELLOW}Connexions SSH disponibles:${NC}"
                echo ""
                
                # Afficher les connexions avec sélection
                for ((i=0; i<${#ssh_connections[@]}; i++)); do
                    local prefix="  "
                    local color=""
                    
                    if [[ $i -eq $selected_ssh_index ]]; then
                        prefix="> "
                        color="${WHITE}"
                    fi
                    
                    echo -e "${prefix}${color}${GREEN}[SSH]${NC} ${color}${ssh_connections[$i]}${NC}"
                done
                
                echo ""
                echo -e "${YELLOW}Contrôles:${NC}"
                echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
                echo -e "  ${GREEN}Entrée${NC} : Sélectionner cette connexion"
                echo -e "  ${GREEN}m${NC} : Saisie manuelle"
                echo -e "  ${GREEN}q${NC} : Annuler"
                echo ""
                
                # Lire la touche
                read -rsn1 key
                
                case "$key" in
                    $'\e')  # Séquence d'échappement
                        read -rsn2 key
                        case "$key" in
                            '[A')  # Flèche haut
                                if [[ $selected_ssh_index -gt 0 ]]; then
                                    selected_ssh_index=$((selected_ssh_index - 1))
                                fi
                                ;;
                            '[B')  # Flèche bas
                                if [[ $selected_ssh_index -lt $((${#ssh_connections[@]} - 1)) ]]; then
                                    selected_ssh_index=$((selected_ssh_index + 1))
                                fi
                                ;;
                        esac
                        ;;
                    '')  # Entrée
                        ssh_connection="${ssh_connections[$selected_ssh_index]}"
                        echo -e "${GREEN}Connexion sélectionnée: $ssh_connection${NC}"
                        break
                        ;;
                    'm')  # Saisie manuelle
                        echo -e "${CYAN}Connexion SSH (nom d'hôte ou user@host:port):${NC} "
                        read -r ssh_connection
                        if [[ -z "$ssh_connection" ]]; then
                            echo -e "${YELLOW}Copie annulée${NC}"
                            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                            read
                            return
                        fi
                        break
                        ;;
                    'q')  # Quitter
                        echo -e "${YELLOW}Copie annulée${NC}"
                        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                        read
                        return
                        ;;
                esac
            done
        else
            clear
            echo -e "${WHITE}=== Copie vers machine distante ===${NC}"
            echo -e "${CYAN}Élément:${NC} $item_name"
            echo -e "${CYAN}Type:${NC} $item_type"
            echo ""
            echo -e "${CYAN}Connexion SSH (nom d'hôte ou user@host:port):${NC} "
            read -r ssh_connection
            
            if [[ -z "$ssh_connection" ]]; then
                echo -e "${YELLOW}Copie annulée${NC}"
                echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                read
                return
            fi
        fi
        
        echo -e "${CYAN}Répertoire de destination sur la machine distante:${NC} "
        read -r remote_path
        
        if [[ -z "$remote_path" ]]; then
            remote_path="~"
        fi
        
        echo -e "${YELLOW}Copie en cours...${NC}"
        
        # Effectuer la copie
        if [[ "$item_type" == "dir" ]]; then
            if command -v rsync >/dev/null 2>&1; then
                if rsync -avz -e ssh "$item_path/" "$ssh_connection:$remote_path/$item_name/" 2>/dev/null; then
                    echo -e "${GREEN}Dossier copié avec succès vers $ssh_connection:$remote_path/$item_name${NC}"
                else
                    echo -e "${RED}Erreur lors de la copie du dossier${NC}"
                fi
            else
                if scp -r "$item_path" "$ssh_connection:$remote_path/" 2>/dev/null; then
                    echo -e "${GREEN}Dossier copié avec succès vers $ssh_connection:$remote_path${NC}"
                else
                    echo -e "${RED}Erreur lors de la copie du dossier${NC}"
                fi
            fi
        else
            if scp "$item_path" "$ssh_connection:$remote_path/" 2>/dev/null; then
                echo -e "${GREEN}Fichier copié avec succès vers $ssh_connection:$remote_path${NC}"
            else
                echo -e "${RED}Erreur lors de la copie du fichier${NC}"
            fi
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour copier depuis une machine distante
    ssh_copy_from_remote() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        # Charger les connexions SSH configurées
        local ssh_connections=()
        local ssh_config_file="$HOME/.ssh/config"
        
        if [[ -f "$ssh_config_file" ]]; then
            while IFS= read -r line; do
                if [[ "$line" =~ ^Host[[:space:]]+([^#*[:space:]]+) ]]; then
                    local host_name="${BASH_REMATCH[1]}"
                    if [[ "$host_name" != "*" ]]; then
                        ssh_connections+=("$host_name")
                    fi
                fi
            done < "$ssh_config_file"
        fi
        
        # Si des connexions SSH sont configurées, permettre la navigation
        if [[ ${#ssh_connections[@]} -gt 0 ]]; then
            local selected_ssh_index=0
            
            while true; do
                clear
                echo -e "${WHITE}=== Copie depuis machine distante ===${NC}"
                echo -e "${CYAN}Élément local:${NC} $item_name"
                echo -e "${CYAN}Type:${NC} $item_type"
                echo ""
                echo -e "${YELLOW}Connexions SSH disponibles:${NC}"
                echo ""
                
                # Afficher les connexions avec sélection
                for ((i=0; i<${#ssh_connections[@]}; i++)); do
                    local prefix="  "
                    local color=""
                    
                    if [[ $i -eq $selected_ssh_index ]]; then
                        prefix="> "
                        color="${WHITE}"
                    fi
                    
                    echo -e "${prefix}${color}${GREEN}[SSH]${NC} ${color}${ssh_connections[$i]}${NC}"
                done
                
                echo ""
                echo -e "${YELLOW}Contrôles:${NC}"
                echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
                echo -e "  ${GREEN}Entrée${NC} : Sélectionner cette connexion"
                echo -e "  ${GREEN}m${NC} : Saisie manuelle"
                echo -e "  ${GREEN}q${NC} : Annuler"
                echo ""
                
                # Lire la touche
                read -rsn1 key
                
                case "$key" in
                    $'\e')  # Séquence d'échappement
                        read -rsn2 key
                        case "$key" in
                            '[A')  # Flèche haut
                                if [[ $selected_ssh_index -gt 0 ]]; then
                                    selected_ssh_index=$((selected_ssh_index - 1))
                                fi
                                ;;
                            '[B')  # Flèche bas
                                if [[ $selected_ssh_index -lt $((${#ssh_connections[@]} - 1)) ]]; then
                                    selected_ssh_index=$((selected_ssh_index + 1))
                                fi
                                ;;
                        esac
                        ;;
                    '')  # Entrée
                        ssh_connection="${ssh_connections[$selected_ssh_index]}"
                        echo -e "${GREEN}Connexion sélectionnée: $ssh_connection${NC}"
                        break
                        ;;
                    'm')  # Saisie manuelle
                        echo -e "${CYAN}Connexion SSH (nom d'hôte ou user@host:port):${NC} "
                        read -r ssh_connection
                        if [[ -z "$ssh_connection" ]]; then
                            echo -e "${YELLOW}Copie annulée${NC}"
                            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                            read
                            return
                        fi
                        break
                        ;;
                    'q')  # Quitter
                        echo -e "${YELLOW}Copie annulée${NC}"
                        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                        read
                        return
                        ;;
                esac
            done
        else
            clear
            echo -e "${WHITE}=== Copie depuis machine distante ===${NC}"
            echo -e "${CYAN}Élément local:${NC} $item_name"
            echo -e "${CYAN}Type:${NC} $item_type"
            echo ""
            echo -e "${CYAN}Connexion SSH (nom d'hôte ou user@host:port):${NC} "
            read -r ssh_connection
            
            if [[ -z "$ssh_connection" ]]; then
                echo -e "${YELLOW}Copie annulée${NC}"
                echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                read
                return
            fi
        fi
        
        echo -e "${CYAN}Chemin de l'élément sur la machine distante:${NC} "
        read -r remote_item_path
        
        if [[ -z "$remote_item_path" ]]; then
            echo -e "${YELLOW}Copie annulée${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        echo -e "${CYAN}Nom local (optionnel):${NC} "
        read -r local_name
        
        if [[ -z "$local_name" ]]; then
            local_name=$(basename "$remote_item_path")
        fi
        
        local local_path="$current_dir/$local_name"
        
        # Vérifier si l'élément existe déjà
        if [[ -e "$local_path" ]]; then
            echo -e "${RED}Erreur: Un élément avec ce nom existe déjà${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        echo -e "${YELLOW}Copie en cours...${NC}"
        
        # Effectuer la copie
        if [[ -d "$remote_item_path" ]] || [[ "$remote_item_path" == */ ]]; then
            # C'est un dossier
            if command -v rsync >/dev/null 2>&1; then
                if rsync -avz -e ssh "$ssh_connection:$remote_item_path/" "$local_path/" 2>/dev/null; then
                    echo -e "${GREEN}Dossier copié avec succès depuis $ssh_connection:$remote_item_path${NC}"
                else
                    echo -e "${RED}Erreur lors de la copie du dossier${NC}"
                fi
            else
                if scp -r "$ssh_connection:$remote_item_path" "$local_path" 2>/dev/null; then
                    echo -e "${GREEN}Dossier copié avec succès depuis $ssh_connection:$remote_item_path${NC}"
                else
                    echo -e "${RED}Erreur lors de la copie du dossier${NC}"
                fi
            fi
        else
            # C'est un fichier
            if scp "$ssh_connection:$remote_item_path" "$local_path" 2>/dev/null; then
                echo -e "${GREEN}Fichier copié avec succès depuis $ssh_connection:$remote_item_path${NC}"
            else
                echo -e "${RED}Erreur lors de la copie du fichier${NC}"
            fi
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    
    # Fonction pour générer une commande SCP
    ssh_generate_scp_command() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        # Charger les connexions SSH configurées
        local ssh_connections=()
        local ssh_config_file="$HOME/.ssh/config"
        
        if [[ -f "$ssh_config_file" ]]; then
            while IFS= read -r line; do
                if [[ "$line" =~ ^Host[[:space:]]+([^#*[:space:]]+) ]]; then
                    local host_name="${BASH_REMATCH[1]}"
                    if [[ "$host_name" != "*" ]]; then
                        ssh_connections+=("$host_name")
                    fi
                fi
            done < "$ssh_config_file"
        fi
        
        # Si des connexions SSH sont configurées, permettre la navigation
        if [[ ${#ssh_connections[@]} -gt 0 ]]; then
            local selected_ssh_index=0
            
            while true; do
                clear
                echo -e "${WHITE}=== Générer commande SCP ===${NC}"
                echo -e "${CYAN}Élément:${NC} $item_name"
                echo -e "${CYAN}Type:${NC} $item_type"
                echo -e "${CYAN}Chemin:${NC} $item_path"
                echo ""
                echo -e "${YELLOW}Connexions SSH disponibles:${NC}"
                echo ""
                
                # Afficher les connexions avec sélection
                for ((i=0; i<${#ssh_connections[@]}; i++)); do
                    local prefix="  "
                    local color=""
                    
                    if [[ $i -eq $selected_ssh_index ]]; then
                        prefix="> "
                        color="${WHITE}"
                    fi
                    
                    echo -e "${prefix}${color}${GREEN}[SSH]${NC} ${color}${ssh_connections[$i]}${NC}"
                done
                
                echo ""
                echo -e "${YELLOW}Contrôles:${NC}"
                echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
                echo -e "  ${GREEN}Entrée${NC} : Sélectionner cette connexion"
                echo -e "  ${GREEN}m${NC} : Saisie manuelle"
                echo -e "  ${GREEN}q${NC} : Annuler"
                echo ""
                
                # Lire la touche
                read -rsn1 key
                
                case "$key" in
                    $'\e')  # Séquence d'échappement
                        read -rsn2 key
                        case "$key" in
                            '[A')  # Flèche haut
                                if [[ $selected_ssh_index -gt 0 ]]; then
                                    selected_ssh_index=$((selected_ssh_index - 1))
                                fi
                                ;;
                            '[B')  # Flèche bas
                                if [[ $selected_ssh_index -lt $((${#ssh_connections[@]} - 1)) ]]; then
                                    selected_ssh_index=$((selected_ssh_index + 1))
                                fi
                                ;;
                        esac
                        ;;
                    '')  # Entrée
                        ssh_connection="${ssh_connections[$selected_ssh_index]}"
                        echo -e "${GREEN}Connexion sélectionnée: $ssh_connection${NC}"
                        break
                        ;;
                    'm')  # Saisie manuelle
                        echo -e "${CYAN}Connexion SSH (nom d'hôte ou user@host:port):${NC} "
                        read -r ssh_connection
                        if [[ -z "$ssh_connection" ]]; then
                            echo -e "${YELLOW}Génération annulée${NC}"
                            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                            read
                            return
                        fi
                        break
                        ;;
                    'q')  # Quitter
                        return
                        ;;
                esac
            done
        else
            clear
            echo -e "${WHITE}=== Générer commande SCP ===${NC}"
            echo -e "${CYAN}Élément:${NC} $item_name"
            echo -e "${CYAN}Type:${NC} $item_type"
            echo -e "${CYAN}Chemin:${NC} $item_path"
            echo ""
            echo -e "${CYAN}Connexion SSH (nom d'hôte ou user@host:port):${NC} "
            read -r ssh_connection
            
            if [[ -z "$ssh_connection" ]]; then
                echo -e "${YELLOW}Génération annulée${NC}"
                echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                read
                return
            fi
        fi
        
        # Générer les commandes SCP génériques
        clear
        echo -e "${WHITE}=== Commandes SCP générées ===${NC}"
        echo -e "${CYAN}Élément:${NC} $item_name"
        echo -e "${CYAN}Connexion:${NC} $ssh_connection"
        echo ""
        
        echo -e "${YELLOW}=== Copie VERS la machine distante ===${NC}"
        echo -e "${GREEN}Commande à exécuter sur votre machine locale:${NC}"
        echo ""
        
        if [[ "$item_type" == "dir" ]]; then
            echo -e "${WHITE}scp -r ./$item_name $ssh_connection:~/destination/${NC}"
        else
            echo -e "${WHITE}scp ./$item_name $ssh_connection:~/destination/${NC}"
        fi
        
        echo ""
        echo -e "${YELLOW}=== Copie DEPUIS la machine distante ===${NC}"
        echo -e "${GREEN}Commande à exécuter sur votre machine locale:${NC}"
        echo ""
        
        if [[ "$item_type" == "dir" ]]; then
            echo -e "${WHITE}scp -r $ssh_connection:~/$item_name ./${NC}"
        else
            echo -e "${WHITE}scp $ssh_connection:~/$item_name ./${NC}"
        fi
        
        echo ""
        echo -e "${YELLOW}=== Commandes alternatives avec rsync ===${NC}"
        echo -e "${GREEN}Vers machine distante:${NC}"
        if [[ "$item_type" == "dir" ]]; then
            echo -e "${WHITE}rsync -avz ./$item_name/ $ssh_connection:~/destination/$item_name/${NC}"
        else
            echo -e "${WHITE}rsync -avz ./$item_name $ssh_connection:~/destination/${NC}"
        fi
        
        echo ""
        echo -e "${GREEN}Depuis machine distante:${NC}"
        if [[ "$item_type" == "dir" ]]; then
            echo -e "${WHITE}rsync -avz $ssh_connection:~/$item_name/ ./$item_name/${NC}"
        else
            echo -e "${WHITE}rsync -avz $ssh_connection:~/$item_name ./${NC}"
        fi
        
        echo ""
        echo -e "${YELLOW}Instructions:${NC}"
        echo -e "  • Copiez la commande appropriée"
        echo -e "  • Exécutez-la sur votre machine locale"
        echo -e "  • Assurez-vous que la connexion SSH fonctionne"
        echo ""
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour gérer les connexions SSH
    ssh_manage_connections() {
        local ssh_config_file="$HOME/.ssh/config"
        local ssh_connections=()
        local ssh_connection_details=()
        
        # Charger les connexions SSH configurées
        if [[ -f "$ssh_config_file" ]]; then
            local current_host=""
            local current_user=""
            local current_hostname=""
            local current_port=""
            
            while IFS= read -r line; do
                # Ignorer les commentaires et lignes vides
                if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
                    continue
                fi
                
                # Détecter les sections Host
                if [[ "$line" =~ ^Host[[:space:]]+([^#*[:space:]]+) ]]; then
                    # Sauvegarder la connexion précédente si elle existe
                    if [[ -n "$current_host" && "$current_host" != "*" ]]; then
                        local display_info="$current_host"
                        if [[ -n "$current_user" && -n "$current_hostname" ]]; then
                            display_info="$current_user@$current_hostname"
                            if [[ -n "$current_port" && "$current_port" != "22" ]]; then
                                display_info="$display_info:$current_port"
                            fi
                        fi
                        ssh_connections+=("$current_host")
                        ssh_connection_details+=("$display_info")
                    fi
                    
                    # Nouvelle section Host
                    current_host="${BASH_REMATCH[1]}"
                    current_user=""
                    current_hostname=""
                    current_port=""
                elif [[ "$line" =~ ^[[:space:]]+User[[:space:]]+(.+) ]]; then
                    current_user="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]+HostName[[:space:]]+(.+) ]]; then
                    current_hostname="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]+Port[[:space:]]+(.+) ]]; then
                    current_port="${BASH_REMATCH[1]}"
                fi
            done < "$ssh_config_file"
            
            # Sauvegarder la dernière connexion
            if [[ -n "$current_host" && "$current_host" != "*" ]]; then
                local display_info="$current_host"
                if [[ -n "$current_user" && -n "$current_hostname" ]]; then
                    display_info="$current_user@$current_hostname"
                    if [[ -n "$current_port" && "$current_port" != "22" ]]; then
                        display_info="$display_info:$current_port"
                    fi
                fi
                ssh_connections+=("$current_host")
                ssh_connection_details+=("$display_info")
            fi
        fi
        
        if [[ ${#ssh_connections[@]} -eq 0 ]]; then
            clear
            echo -e "${WHITE}=== Connexions SSH configurées ===${NC}"
            echo ""
            echo -e "${YELLOW}Aucun fichier de configuration SSH trouvé${NC}"
            echo -e "${CYAN}Créez ~/.ssh/config pour configurer vos connexions SSH${NC}"
            echo ""
            echo -e "${YELLOW}Exemple de configuration:${NC}"
            echo -e "Host phloxe-ovh-prod"
            echo -e "    HostName 192.168.1.100"
            echo -e "    User monuser"
            echo -e "    Port 22"
            echo ""
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        local selected_index=0
        
        while true; do
            clear
            echo -e "${WHITE}=== Connexions SSH configurées ===${NC}"
            echo -e "${CYAN}Fichier de configuration:${NC} $ssh_config_file"
            echo ""
            echo -e "${YELLOW}Connexions SSH disponibles:${NC}"
            echo ""
            
            # Afficher les connexions avec sélection
            for ((i=0; i<${#ssh_connections[@]}; i++)); do
                local prefix="  "
                local color=""
                
                if [[ $i -eq $selected_index ]]; then
                    prefix="> "
                    color="${WHITE}"
                fi
                
                echo -e "${prefix}${color}${GREEN}[SSH]${NC} ${color}${ssh_connections[$i]}${NC} -> ${CYAN}${ssh_connection_details[$i]}${NC}"
            done
            
            echo ""
            echo -e "${YELLOW}Contrôles:${NC}"
            echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
            echo -e "  ${GREEN}Entrée${NC} : Sélectionner cette connexion"
            echo -e "  ${GREEN}c${NC} : Copier le nom de la connexion"
            echo -e "  ${GREEN}q${NC} : Retour"
            echo ""
            echo -e "${YELLOW}Utilisation:${NC}"
            echo -e "  • Utilisez le nom d'hôte affiché pour les connexions"
            echo -e "  • Ou utilisez le format complet user@host:port"
            echo ""
            
            # Lire la touche
            read -rsn1 key
            
            case "$key" in
                $'\e')  # Séquence d'échappement
                    read -rsn2 key
                    case "$key" in
                        '[A')  # Flèche haut
                            if [[ $selected_index -gt 0 ]]; then
                                selected_index=$((selected_index - 1))
                            fi
                            ;;
                        '[B')  # Flèche bas
                            if [[ $selected_index -lt $((${#ssh_connections[@]} - 1)) ]]; then
                                selected_index=$((selected_index + 1))
                            fi
                            ;;
                    esac
                    ;;
                '')  # Entrée
                    local selected_connection="${ssh_connections[$selected_index]}"
                    echo -e "${GREEN}Connexion sélectionnée: $selected_connection${NC}"
                    echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                    read
                    return
                    ;;
                'c')  # Copier le nom
                    local selected_connection="${ssh_connections[$selected_index]}"
                    echo -e "${GREEN}Nom de connexion: $selected_connection${NC}"
                    echo -e "${YELLOW}Utilisez ce nom pour vos connexions SSH${NC}"
                    echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                    read
                    ;;
                'q')  # Quitter
                    return
                    ;;
            esac
        done
    }
    
    
    # Fonction pour zipper un élément
    zip_item() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        clear
        echo -e "${WHITE}=== Zipper ===${NC}"
        echo -e "${CYAN}Élément:${NC} $item_name"
        echo -e "${CYAN}Type:${NC} $item_type"
        echo -e "${CYAN}Chemin:${NC} $item_path"
        echo ""
        
        # Vérifier si zip est disponible
        if ! command -v zip >/dev/null 2>&1; then
            echo -e "${RED}Erreur: La commande 'zip' n'est pas disponible${NC}"
            echo -e "${YELLOW}Veuillez installer zip pour utiliser cette fonctionnalité${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        # Demander le nom du fichier zip
        local zip_name="${item_name%.*}.zip"
        echo -e "${CYAN}Nom du fichier zip (défaut: $zip_name):${NC} "
        read -r custom_zip_name
        
        if [[ -n "$custom_zip_name" ]]; then
            zip_name="$custom_zip_name"
            # Ajouter l'extension .zip si elle n'est pas présente
            if [[ "$zip_name" != *.zip ]]; then
                zip_name="${zip_name}.zip"
            fi
        fi
        
        local zip_path="$current_dir/$zip_name"
        
        # Vérifier si le fichier zip existe déjà
        if [[ -e "$zip_path" ]]; then
            echo -e "${RED}Erreur: Un fichier avec ce nom existe déjà${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        echo -e "${YELLOW}Compression en cours...${NC}"
        
        # Effectuer la compression
        if [[ "$item_type" == "dir" ]]; then
            # Pour un dossier, compresser le contenu
            if (cd "$(dirname "$item_path")" && zip -r "$zip_path" "$(basename "$item_path")" >/dev/null 2>&1); then
                echo -e "${GREEN}Dossier compressé avec succès: $zip_name${NC}"
            else
                echo -e "${RED}Erreur lors de la compression du dossier${NC}"
            fi
        else
            # Pour un fichier, le compresser directement
            if (cd "$(dirname "$item_path")" && zip "$zip_path" "$(basename "$item_path")" >/dev/null 2>&1); then
                echo -e "${GREEN}Fichier compressé avec succès: $zip_name${NC}"
            else
                echo -e "${RED}Erreur lors de la compression du fichier${NC}"
            fi
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour dézipper un fichier
    unzip_item() {
        local item_path="$1"
        local item_name="$2"
        local item_type="$3"
        
        clear
        echo -e "${WHITE}=== Dézipper ===${NC}"
        echo -e "${CYAN}Élément:${NC} $item_name"
        echo -e "${CYAN}Type:${NC} $item_type"
        echo -e "${CYAN}Chemin:${NC} $item_path"
        echo ""
        
        # Vérifier si unzip est disponible
        if ! command -v unzip >/dev/null 2>&1; then
            echo -e "${RED}Erreur: La commande 'unzip' n'est pas disponible${NC}"
            echo -e "${YELLOW}Veuillez installer unzip pour utiliser cette fonctionnalité${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        # Vérifier que c'est bien un fichier zip
        if ! unzip -t "$item_path" >/dev/null 2>&1; then
            echo -e "${RED}Erreur: Ce fichier n'est pas un fichier zip valide${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        # Demander le répertoire de destination
        local dest_dir="$current_dir"
        echo -e "${CYAN}Répertoire de destination (défaut: $dest_dir):${NC} "
        read -r custom_dest_dir
        
        if [[ -n "$custom_dest_dir" ]]; then
            dest_dir="$custom_dest_dir"
            # Convertir le chemin relatif en absolu si nécessaire
            if [[ "$dest_dir" != /* ]]; then
                dest_dir="$current_dir/$dest_dir"
            fi
        fi
        
        # Vérifier que le répertoire de destination existe
        if [[ ! -d "$dest_dir" ]]; then
            echo -e "${RED}Erreur: Le répertoire de destination n'existe pas${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        echo -e "${YELLOW}Décompression en cours...${NC}"
        
        # Effectuer la décompression
        if (cd "$dest_dir" && unzip -q "$item_path" 2>/dev/null); then
            echo -e "${GREEN}Fichier décompressé avec succès dans: $dest_dir${NC}"
            
            # Afficher le contenu décompressé
            echo -e "${CYAN}Contenu décompressé:${NC}"
            (cd "$dest_dir" && unzip -l "$item_path" 2>/dev/null | tail -n +4 | head -n -2 | awk '{print "  " $4}' | head -10)
            local total_files=$(unzip -l "$item_path" 2>/dev/null | tail -1 | awk '{print $2}')
            if [[ $total_files -gt 10 ]]; then
                echo -e "  ${PURPLE}... et $((total_files - 10)) autres fichiers${NC}"
            fi
        else
            echo -e "${RED}Erreur lors de la décompression${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour créer un fichier
    create_file() {
        local parent_dir="$1"
        
        clear
        echo -e "${WHITE}=== Créer un fichier ===${NC}"
        echo -e "${CYAN}Répertoire parent:${NC} $parent_dir"
        echo ""
        echo -e "${CYAN}Nom du fichier:${NC} "
        read -r file_name
        
        if [[ -n "$file_name" ]]; then
            local file_path="$parent_dir/$file_name"
            if [[ -e "$file_path" ]]; then
                echo -e "${RED}Erreur: Un fichier avec ce nom existe déjà${NC}"
            else
                if touch "$file_path" 2>/dev/null; then
                    echo -e "${GREEN}Fichier créé avec succès: $file_name${NC}"
                else
                    echo -e "${RED}Erreur lors de la création du fichier${NC}"
                fi
            fi
        else
            echo -e "${YELLOW}Création annulée${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour créer un dossier
    create_directory() {
        local parent_dir="$1"
        
        clear
        echo -e "${WHITE}=== Créer un dossier ===${NC}"
        echo -e "${CYAN}Répertoire parent:${NC} $parent_dir"
        echo ""
        echo -e "${CYAN}Nom du dossier:${NC} "
        read -r dir_name
        
        if [[ -n "$dir_name" ]]; then
            local dir_path="$parent_dir/$dir_name"
            if [[ -e "$dir_path" ]]; then
                echo -e "${RED}Erreur: Un dossier avec ce nom existe déjà${NC}"
            else
                if mkdir "$dir_path" 2>/dev/null; then
                    echo -e "${GREEN}Dossier créé avec succès: $dir_name${NC}"
                else
                    echo -e "${RED}Erreur lors de la création du dossier${NC}"
                fi
            fi
        else
            echo -e "${YELLOW}Création annulée${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour ouvrir un fichier
    open_file() {
        local file_path="$1"
        local file_name=$(basename "$file_path")
        
        # Définir les outils disponibles
        local tools=("nano" "cat" "catimg" "vim" "code" "cursor" "autres")
        local tool_names=("nano" "cat" "catimg" "vim" "VS Code" "Cursor" "Autres (spécifier)")
        local selected_tool=0
        
        while true; do
            clear
            echo -e "${WHITE}=== Ouvrir le fichier ===${NC}"
            echo -e "${CYAN}Fichier:${NC} $file_name"
            echo -e "${CYAN}Chemin:${NC} $file_path"
            echo ""
            echo -e "${YELLOW}Choisissez un outil:${NC}"
            echo ""
            
            # Afficher les outils avec sélection
            for ((i=0; i<${#tools[@]}; i++)); do
                local prefix="  "
                local color=""
                
                if [[ $i -eq $selected_tool ]]; then
                    prefix="> "
                    color="${WHITE}"
                fi
                
                echo -e "${prefix}${color}${GREEN}[TOOL]${NC} ${color}${tool_names[$i]}${NC}"
            done
            
            echo ""
            echo -e "${YELLOW}Contrôles:${NC}"
            echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
            echo -e "  ${GREEN}Entrée${NC} : Sélectionner"
            echo -e "  ${GREEN}q${NC} : Annuler"
            echo ""
            
            # Lire la touche
            read -rsn1 key
            
            case "$key" in
                $'\e')  # Séquence d'échappement
                    read -rsn2 key
                    case "$key" in
                        '[A')  # Flèche haut
                            if [[ $selected_tool -gt 0 ]]; then
                                selected_tool=$((selected_tool - 1))
                            fi
                            ;;
                        '[B')  # Flèche bas
                            if [[ $selected_tool -lt $((${#tools[@]} - 1)) ]]; then
                                selected_tool=$((selected_tool + 1))
                            fi
                            ;;
                    esac
                    ;;
                '')  # Entrée
                    local chosen_tool="${tools[$selected_tool]}"
                    
                    if [[ "$chosen_tool" == "autres" ]]; then
                        echo ""
                        echo -e "${CYAN}Entrez le nom de l'outil:${NC} "
                        read -r custom_tool
                        if [[ -n "$custom_tool" ]]; then
                            echo -e "${YELLOW}Ouverture avec $custom_tool...${NC}"
                            $custom_tool "$file_path"
                            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                            read
                        else
                            echo -e "${RED}Outil non spécifié${NC}"
                            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                            read
                        fi
                    else
                        echo -e "${YELLOW}Ouverture avec $chosen_tool...${NC}"
                        $chosen_tool "$file_path"
                        if [[ "$chosen_tool" == "catimg" || "$chosen_tool" == "cat" ]]; then
                            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                            read
                        fi
                    fi
                    return
                    ;;
                'q')  # Quitter
                    echo -e "${YELLOW}Annulé${NC}"
                    return
                    ;;
            esac
        done
    }
    
    # Fonction pour gérer le repository Git
    git_manager() {
        # Vérifier si git est disponible
        if ! command -v git >/dev/null 2>&1; then
            echo -e "${RED}Erreur: Git n'est pas installé${NC}"
            echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
            read
            return
        fi
        
        # Définir les options du menu Git
        local git_options=("Statut" "Log" "Branches" "Diff" "Add" "Commit" "Push" "Pull" "Clone" "Init")
        local selected_option=0
        
        while true; do
            clear
            echo -e "${WHITE}=== Gestionnaire Git ===${NC}"
            echo -e "${CYAN}Repository:${NC} $(realpath "$current_dir")"
            echo -e "${CYAN}Branche actuelle:${NC} $(git -C "$current_dir" branch --show-current 2>/dev/null || echo "N/A")"
            echo -e "${CYAN}Dernier commit:${NC} $(git -C "$current_dir" log -1 --oneline 2>/dev/null || echo "N/A")"
            echo ""
            echo -e "${YELLOW}Actions disponibles:${NC}"
            echo ""
            
            # Afficher les options avec sélection
            for ((i=0; i<${#git_options[@]}; i++)); do
                local prefix="  "
                local color=""
                
                if [[ $i -eq $selected_option ]]; then
                    prefix="> "
                    color="${WHITE}"
                fi
                
                echo -e "${prefix}${color}${GREEN}[GIT]${NC} ${color}${git_options[$i]}${NC}"
            done
            
            echo ""
            echo -e "${YELLOW}Contrôles:${NC}"
            echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
            echo -e "  ${GREEN}Entrée${NC} : Sélectionner"
            echo -e "  ${GREEN}q${NC} : Retour"
            echo ""
            
            # Lire la touche
            read -rsn1 key
            
            case "$key" in
                $'\e')  # Séquence d'échappement
                    read -rsn2 key
                    case "$key" in
                        '[A')  # Flèche haut
                            if [[ $selected_option -gt 0 ]]; then
                                selected_option=$((selected_option - 1))
                            fi
                            ;;
                        '[B')  # Flèche bas
                            if [[ $selected_option -lt $((${#git_options[@]} - 1)) ]]; then
                                selected_option=$((selected_option + 1))
                            fi
                            ;;
                    esac
                    ;;
                '')  # Entrée
                    local chosen_action="${git_options[$selected_option]}"
                    
                    case "$chosen_action" in
                        "Statut")
                            git_status_view
                            ;;
                        "Log")
                            git_log_view
                            ;;
                        "Branches")
                            git_branches_view
                            ;;
                        "Diff")
                            git_diff_view
                            ;;
                        "Add")
                            git_add_files
                            ;;
                        "Commit")
                            git_commit_changes
                            ;;
                        "Push")
                            git_push_changes
                            ;;
                        "Pull")
                            git_pull_changes
                            ;;
                        "Clone")
                            git_clone_repo
                            ;;
                        "Init")
                            git_init_repo
                            ;;
                    esac
                    return
                    ;;
                'q')  # Quitter
                    return
                    ;;
            esac
        done
    }
    
    # Fonction pour afficher le statut Git
    git_status_view() {
        clear
        echo -e "${WHITE}=== Statut Git ===${NC}"
        echo -e "${CYAN}Repository:${NC} $(realpath "$current_dir")"
        echo ""
        
        # Afficher le statut
        echo -e "${YELLOW}Statut:${NC}"
        git -C "$current_dir" status --porcelain 2>/dev/null | while read -r line; do
            local status="${line:0:2}"
            local file="${line:3}"
            
            case "$status" in
                "??")
                    echo -e "  ${GREEN}Nouveau:${NC} $file"
                    ;;
                "A ")
                    echo -e "  ${BLUE}Ajouté:${NC} $file"
                    ;;
                "M ")
                    echo -e "  ${YELLOW}Modifié:${NC} $file"
                    ;;
                " D")
                    echo -e "  ${RED}Supprimé:${NC} $file"
                    ;;
                "MM")
                    echo -e "  ${PURPLE}Modifié (staged):${NC} $file"
                    ;;
                *)
                    echo -e "  ${WHITE}$status:${NC} $file"
                    ;;
            esac
        done
        
        echo ""
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour afficher le log Git
    git_log_view() {
        clear
        echo -e "${WHITE}=== Log Git ===${NC}"
        echo -e "${CYAN}Repository:${NC} $(realpath "$current_dir")"
        echo ""
        
        # Afficher les 10 derniers commits
        echo -e "${YELLOW}Derniers commits:${NC}"
        git -C "$current_dir" log --oneline -10 2>/dev/null | while read -r line; do
            echo -e "  ${GREEN}$line${NC}"
        done
        
        echo ""
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour afficher les branches
    git_branches_view() {
        clear
        echo -e "${WHITE}=== Branches Git ===${NC}"
        echo -e "${CYAN}Repository:${NC} $(realpath "$current_dir")"
        echo ""
        
        # Afficher les branches locales
        echo -e "${YELLOW}Branches locales:${NC}"
        git -C "$current_dir" branch 2>/dev/null | while read -r line; do
            if [[ "$line" =~ ^\* ]]; then
                echo -e "  ${GREEN}→ $line${NC}"
            else
                echo -e "  ${WHITE}  $line${NC}"
            fi
        done
        
        echo ""
        echo -e "${YELLOW}Branches distantes:${NC}"
        git -C "$current_dir" branch -r 2>/dev/null | while read -r line; do
            echo -e "  ${BLUE}$line${NC}"
        done
        
        echo ""
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour afficher les différences
    git_diff_view() {
        clear
        echo -e "${WHITE}=== Diff Git ===${NC}"
        echo -e "${CYAN}Repository:${NC} $(realpath "$current_dir")"
        echo ""
        
        # Afficher les différences
        echo -e "${YELLOW}Différences:${NC}"
        git -C "$current_dir" diff --stat 2>/dev/null
        
        echo ""
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour ajouter des fichiers
    git_add_files() {
        clear
        echo -e "${WHITE}=== Git Add ===${NC}"
        echo -e "${CYAN}Repository:${NC} $(realpath "$current_dir")"
        echo ""
        
        echo -e "${CYAN}Entrez le fichier à ajouter (ou '.' pour tout):${NC} "
        read -r file_to_add
        
        if [[ -n "$file_to_add" ]]; then
            echo -e "${YELLOW}Ajout en cours...${NC}"
            if git -C "$current_dir" add "$file_to_add" 2>/dev/null; then
                echo -e "${GREEN}Fichier(s) ajouté(s) avec succès${NC}"
            else
                echo -e "${RED}Erreur lors de l'ajout${NC}"
            fi
        else
            echo -e "${YELLOW}Ajout annulé${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour faire un commit
    git_commit_changes() {
        clear
        echo -e "${WHITE}=== Git Commit ===${NC}"
        echo -e "${CYAN}Repository:${NC} $(realpath "$current_dir")"
        echo ""
        
        echo -e "${CYAN}Message de commit:${NC} "
        read -r commit_message
        
        if [[ -n "$commit_message" ]]; then
            echo -e "${YELLOW}Commit en cours...${NC}"
            if git -C "$current_dir" commit -m "$commit_message" 2>/dev/null; then
                echo -e "${GREEN}Commit effectué avec succès${NC}"
            else
                echo -e "${RED}Erreur lors du commit${NC}"
            fi
        else
            echo -e "${YELLOW}Commit annulé${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour push
    git_push_changes() {
        clear
        echo -e "${WHITE}=== Git Push ===${NC}"
        echo -e "${CYAN}Repository:${NC} $(realpath "$current_dir")"
        echo ""
        
        echo -e "${CYAN}Branche distante (défaut: origin):${NC} "
        read -r remote_branch
        
        if [[ -z "$remote_branch" ]]; then
            remote_branch="origin"
        fi
        
        echo -e "${YELLOW}Push en cours...${NC}"
        if git -C "$current_dir" push "$remote_branch" 2>/dev/null; then
            echo -e "${GREEN}Push effectué avec succès${NC}"
        else
            echo -e "${RED}Erreur lors du push${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour pull
    git_pull_changes() {
        clear
        echo -e "${WHITE}=== Git Pull ===${NC}"
        echo -e "${CYAN}Repository:${NC} $(realpath "$current_dir")"
        echo ""
        
        echo -e "${CYAN}Branche distante (défaut: origin):${NC} "
        read -r remote_branch
        
        if [[ -z "$remote_branch" ]]; then
            remote_branch="origin"
        fi
        
        echo -e "${YELLOW}Pull en cours...${NC}"
        if git -C "$current_dir" pull "$remote_branch" 2>/dev/null; then
            echo -e "${GREEN}Pull effectué avec succès${NC}"
        else
            echo -e "${RED}Erreur lors du pull${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour cloner un repository
    git_clone_repo() {
        clear
        echo -e "${WHITE}=== Git Clone ===${NC}"
        echo -e "${CYAN}Répertoire courant:${NC} $(realpath "$current_dir")"
        echo ""
        
        echo -e "${CYAN}URL du repository à cloner:${NC} "
        read -r repo_url
        
        if [[ -n "$repo_url" ]]; then
            echo -e "${CYAN}Nom du dossier (optionnel):${NC} "
            read -r folder_name
            
            echo -e "${YELLOW}Clone en cours...${NC}"
            if [[ -n "$folder_name" ]]; then
                if git clone "$repo_url" "$folder_name" 2>/dev/null; then
                    echo -e "${GREEN}Repository cloné avec succès dans: $folder_name${NC}"
                else
                    echo -e "${RED}Erreur lors du clone${NC}"
                fi
            else
                if git clone "$repo_url" 2>/dev/null; then
                    echo -e "${GREEN}Repository cloné avec succès${NC}"
                else
                    echo -e "${RED}Erreur lors du clone${NC}"
                fi
            fi
        else
            echo -e "${YELLOW}Clone annulé${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour initialiser un repository
    git_init_repo() {
        clear
        echo -e "${WHITE}=== Git Init ===${NC}"
        echo -e "${CYAN}Répertoire:${NC} $(realpath "$current_dir")"
        echo ""
        
        echo -e "${RED}ATTENTION: Cela va initialiser un nouveau repository Git dans ce répertoire${NC}"
        echo -e "${CYAN}Êtes-vous sûr ? (y/n):${NC} "
        read -r confirmation
        
        if [[ "$confirmation" == "y" || "$confirmation" == "Y" ]]; then
            echo -e "${YELLOW}Initialisation en cours...${NC}"
            if git -C "$current_dir" init 2>/dev/null; then
                echo -e "${GREEN}Repository Git initialisé avec succès${NC}"
            else
                echo -e "${RED}Erreur lors de l'initialisation${NC}"
            fi
        else
            echo -e "${YELLOW}Initialisation annulée${NC}"
        fi
        
        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
        read
    }
    
    # Fonction pour lancer une recherche interactive
    launch_search() {
        echo ""
        echo -e "${CYAN}Entrez votre terme de recherche:${NC}"
        read -p "> " search_term
        
        if [[ -n "$search_term" ]]; then
            echo ""
            echo -e "${YELLOW}Recherche de \"$search_term\" dans $current_dir...${NC}"
            echo ""
            
            # Utiliser la fonction de recherche dédiée
            search_interactive "$search_term" "$current_dir"
            
            if [[ ${#SEARCH_RESULTS[@]} -eq 0 ]]; then
                echo -e "${RED}Aucun résultat trouvé pour \"$search_term\"${NC}"
                echo ""
                echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                read
                return
            fi
            
            # Mode navigation dans les résultats
            local result_index=0
            local result_page=0
            local results_per_page=10
            
            while true; do
                clear
                echo -e "${WHITE}=== Résultats de recherche ===${NC}"
                echo -e "${CYAN}Recherche:${NC} \"$search_term\""
                echo -e "${CYAN}Répertoire:${NC} $current_dir"
                echo -e "${CYAN}Résultats:${NC} ${#SEARCH_RESULTS[@]} trouvé(s)"
                echo ""
                echo -e "${YELLOW}Contrôles:${NC}"
                echo -e "  ${GREEN}↑/↓${NC} : Naviguer"
                echo -e "  ${GREEN}Entrée${NC} : Entrer dans le dossier / Ouvrir le fichier"
                echo -e "  ${GREEN}←/→${NC} : Page précédente/suivante"
                echo -e "  ${GREEN}q${NC} : Retour au mode interactif"
                echo ""
                
                # Calculer les indices de pagination
                local total_pages=$(( (${#SEARCH_RESULTS[@]} + results_per_page - 1) / results_per_page ))
                local start_index=$((result_page * results_per_page))
                local end_index=$((start_index + results_per_page - 1))
                
                # Ajuster l'index sélectionné si nécessaire
                if [[ $result_index -ge ${#SEARCH_RESULTS[@]} ]]; then
                    result_index=$((${#SEARCH_RESULTS[@]} - 1))
                fi
                if [[ $result_index -lt 0 ]]; then
                    result_index=0
                fi
                
                # Ajuster la page courante si nécessaire
                local selected_page=$((result_index / results_per_page))
                if [[ $selected_page -ne $result_page ]]; then
                    result_page=$selected_page
                    start_index=$((result_page * results_per_page))
                    end_index=$((start_index + results_per_page - 1))
                fi
                
                # Afficher les résultats de la page courante
                for ((i=start_index; i<=end_index && i<${#SEARCH_RESULTS[@]}; i++)); do
                    local result="${SEARCH_RESULTS[$i]}"
                    local type="${SEARCH_TYPES[$i]}"
                    local size="${SEARCH_SIZES[$i]}"
                    local modified="${SEARCH_MODIFIED[$i]}"
                    local created="${SEARCH_CREATED[$i]}"
                    local prefix="  "
                    local color=""
                    
                    if [[ $i -eq $result_index ]]; then
                        prefix="> "
                        color="${WHITE}"
                    fi
                    
                    if [[ "$type" == "dir" ]]; then
                        echo -e "${prefix}${color}${BLUE}[DIR]${NC} ${color}$result${NC} ${YELLOW}$size${NC} ${PURPLE}Mod: $modified${NC} ${CYAN}Créé: $created${NC}"
                    else
                        echo -e "${prefix}${color}${GREEN}[FILE]${NC} ${color}$result${NC} ${YELLOW}$size${NC} ${PURPLE}Mod: $modified${NC} ${CYAN}Créé: $created${NC}"
                    fi
                done
                
                # Afficher les informations de pagination
                echo ""
                echo -e "${PURPLE}Page $((result_page + 1))/$total_pages - Résultat $((result_index + 1))/${#SEARCH_RESULTS[@]}${NC}"
                
                # Lire la touche
                read -rsn1 key
                
                case "$key" in
                    $'\x1b')  # Séquence d'échappement (flèches)
                        read -rsn2 key
                        case "$key" in
                            '[A')  # Flèche haut
                                if [[ $result_index -gt 0 ]]; then
                                    result_index=$((result_index - 1))
                                fi
                                ;;
                            '[B')  # Flèche bas
                                if [[ $result_index -lt $((${#SEARCH_RESULTS[@]} - 1)) ]]; then
                                    result_index=$((result_index + 1))
                                fi
                                ;;
                            '[C')  # Flèche droite (page suivante)
                                if [[ $result_page -lt $((total_pages - 1)) ]]; then
                                    result_page=$((result_page + 1))
                                    result_index=$((result_page * results_per_page))
                                fi
                                ;;
                            '[D')  # Flèche gauche (page précédente)
                                if [[ $result_page -gt 0 ]]; then
                                    result_page=$((result_page - 1))
                                    result_index=$((result_page * results_per_page))
                                fi
                                ;;
                        esac
                        ;;
                    '')  # Entrée
                        if [[ ${#SEARCH_RESULTS[@]} -gt 0 ]]; then
                            local selected_result="${SEARCH_RESULTS[$result_index]}"
                            local selected_type="${SEARCH_TYPES[$result_index]}"
                            
                            if [[ "$selected_type" == "dir" ]]; then
                                # Entrer dans le dossier
                                current_dir="$selected_result"
                                selected_index=0
                                current_page=0
                                return
                            else
                                # Ouvrir le fichier
                                open_file "$selected_result"
                            fi
                        fi
                        ;;
                    'q')  # Quitter
                        return
                        ;;
                esac
            done
        fi
    }
    
    # Boucle principale
    while true; do
        get_directory_items
        display_interface
        
        # Lire la touche
        read -rsn1 key
        
        case "$key" in
            $'\x1b')  # Séquence d'échappement (flèches)
                read -rsn2 key
                case "$key" in
                    '[A')  # Flèche haut
                        if [[ $selected_index -gt 0 ]]; then
                            selected_index=$((selected_index - 1))
                        fi
                        ;;
                    '[B')  # Flèche bas
                        if [[ $selected_index -lt $((${#items[@]} - 1)) ]]; then
                            selected_index=$((selected_index + 1))
                        fi
                        ;;
                    '[C')  # Flèche droite (page suivante)
                        local total_pages=$(( (${#items[@]} + items_per_page - 1) / items_per_page ))
                        if [[ $current_page -lt $((total_pages - 1)) ]]; then
                            current_page=$((current_page + 1))
                            selected_index=$((current_page * items_per_page))
                        fi
                        ;;
                    '[D')  # Flèche gauche (page précédente)
                        if [[ $current_page -gt 0 ]]; then
                            current_page=$((current_page - 1))
                            selected_index=$((current_page * items_per_page))
                        fi
                        ;;
                esac
                ;;
            '')  # Entrée
                if [[ ${#items[@]} -gt 0 ]]; then
                    local selected_item="${items[$selected_index]}"
                    local selected_type="${item_types[$selected_index]}"
                    
                    if [[ "$selected_type" == "dir" ]]; then
                        if [[ "$selected_item" == ".." ]]; then
                            # Navigation vers le répertoire parent
                            if [[ "$current_dir" == "/" ]]; then
                                # On est déjà à la racine, ne rien faire
                                continue
                            else
                                # Obtenir le répertoire parent de manière plus robuste
                                if [[ "$current_dir" == *"/"* ]]; then
                                    # Enlever le dernier segment du chemin
                                    current_dir="${current_dir%/*}"
                                    # S'assurer qu'on ne va pas en dessous de la racine
                                    if [[ -z "$current_dir" ]]; then
                                        current_dir="/"
                                    fi
                                else
                                    current_dir="/"
                                fi
                            fi
                        else
                            current_dir="$current_dir/$selected_item"
                        fi
                        selected_index=0
                        current_page=0
                    elif [[ "$selected_type" == "file" ]]; then
                        # Ouvrir le fichier
                        open_file "$current_dir/$selected_item"
                    fi
                fi
                ;;
            '/')  # Recherche
                launch_search
                ;;
            'm')  # Menu contextuel
                context_menu
                ;;
            's')  # Sélectionner ce répertoire
                echo ""
                echo -e "${GREEN}Répertoire sélectionné: $current_dir${NC}"
                echo -e "${YELLOW}Changement de répertoire...${NC}"
                
                # Détecter le shell actuel de l'utilisateur
                local current_shell=$(basename "$SHELL")
                echo -e "${CYAN}Redirection vers $current_dir avec $current_shell...${NC}"
                
                case "$current_shell" in
                    bash)
                        exec bash --rcfile <(echo "cd \"$current_dir\"; exec bash")
                        ;;
                    zsh)
                        exec zsh --rcs -c "cd \"$current_dir\"; exec zsh"
                        ;;
                    *)
                        echo -e "${RED}Shell non géré : $current_shell${NC}"
                        echo -e "${YELLOW}Veuillez exécuter : cd \"$current_dir\"${NC}"
                        echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                        read
                        ;;
                esac
                ;;
            'h')  # Basculer les fichiers cachés
                if [[ "$SHOW_HIDDEN" == true ]]; then
                    SHOW_HIDDEN=false
                else
                    SHOW_HIDDEN=true
                fi
                selected_index=0
                current_page=0
                ;;
            'g')  # Gérer le repository Git
                if [[ -d "$current_dir/.git" ]]; then
                    git_manager
                else
                    echo -e "${RED}Ce répertoire n'est pas un repository Git${NC}"
                    echo -e "${YELLOW}Appuyez sur Entrée pour continuer...${NC}"
                    read
                fi
                ;;
            $'\x7f')  # Backspace (même effet que Entrée sur ..)
                if [[ ${#items[@]} -gt 0 ]]; then
                    local selected_item="${items[$selected_index]}"
                    local selected_type="${item_types[$selected_index]}"
                    
                    if [[ "$selected_item" == ".." ]]; then
                        # Navigation vers le répertoire parent
                        if [[ "$current_dir" == "/" ]]; then
                            # On est déjà à la racine, ne rien faire
                            continue
                        else
                            # Obtenir le répertoire parent de manière plus robuste
                            if [[ "$current_dir" == *"/"* ]]; then
                                # Enlever le dernier segment du chemin
                                current_dir="${current_dir%/*}"
                                # S'assurer qu'on ne va pas en dessous de la racine
                                if [[ -z "$current_dir" ]]; then
                                    current_dir="/"
                                fi
                            else
                                current_dir="/"
                            fi
                        fi
                        selected_index=0
                        current_page=0
                    fi
                fi
                ;;
            'q')  # Quitter
                echo ""
                echo -e "${GREEN}Au revoir !${NC}"
                exit 0
                ;;
        esac
    done
}

# Fonction principale
main() {
    local search_pattern=""
    local search_directory="."
    local search_content_flag=false
    
    # Parser les arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -d|--directory)
                search_directory="$2"
                shift 2
                ;;
            -t|--type)
                SEARCH_TYPE="$2"
                if [[ ! "$SEARCH_TYPE" =~ ^(files|dirs|both)$ ]]; then
                    echo -e "${RED}Erreur: Type invalide. Utilisez: files, dirs, ou both${NC}"
                    exit 1
                fi
                shift 2
                ;;
            -i|--interactive)
                INTERACTIVE_MODE=true
                shift
                ;;
            -ic|--ignore-case)
                CASE_SENSITIVE=false
                shift
                ;;
            -r|--regex)
                REGEX_MODE=true
                shift
                ;;
            -e|--exact)
                EXACT_MATCH=true
                shift
                ;;
            -s|--spotlight)
                USE_SPOTLIGHT=true
                shift
                ;;
            -a|--all)
                SHOW_HIDDEN=true
                shift
                ;;
            -mdh | --max-depth)
                MAX_DEPTH="$2"
                shift 2
                ;;
            -mis | --min-size)
                MIN_SIZE="$2"
                shift 2
                ;;
            -mas | --max-size)
                MAX_SIZE="$2"
                shift 2
                ;;
            -md | --modified)
                MODIFIED_DAYS="$2"
                shift 2
                ;;
            -fo | --format)
                OUTPUT_FORMAT="$2"
                if [[ ! "$OUTPUT_FORMAT" =~ ^(detailed|simple|json)$ ]]; then
                    echo -e "${RED}Erreur: Format invalide. Utilisez: detailed, simple, ou json${NC}"
                    exit 1
                fi
                shift 2
                ;;
            -c|--content)
                search_content_flag=true
                shift
                ;;
            -*)
                echo -e "${RED}Erreur: Option inconnue $1${NC}"
                show_help
                exit 1
                ;;
            *)
                if [[ -z "$search_pattern" ]]; then
                    search_pattern="$1"
                elif [[ "$search_directory" == "." ]]; then
                    search_directory="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Si le mode interactif est activé
    if [[ "$INTERACTIVE_MODE" == true ]]; then
        # Résoudre le chemin en chemin absolu
        local abs_search_dir
        if [[ "$search_directory" == "." || "$search_directory" == "./" ]]; then
            abs_search_dir=$(pwd)
        else
            abs_search_dir=$(cd "$search_directory" 2>/dev/null && pwd || echo "$search_directory")
        fi
        interactive_mode "$abs_search_dir"
        exit 0
    fi
    
    # Si aucun pattern n'est fourni, afficher le contenu du dossier courant
    if [[ -z "$search_pattern" ]]; then
        echo -e "${WHITE}=== Contenu du dossier courant ===${NC}"
        echo -e "${CYAN}Répertoire:${NC} $search_directory"
        echo -e "${CYAN}Type:${NC} $SEARCH_TYPE"
        echo -e "${CYAN}Profondeur max:${NC} $MAX_DEPTH"
        echo -e "${CYAN}Fichiers cachés:${NC} $SHOW_HIDDEN"
        echo ""
        
        # Utiliser ls pour un affichage rapide et esthétique
        local ls_options="-lh"
        
        # Ajouter l'option pour les fichiers cachés
        if [[ "$SHOW_HIDDEN" == true ]]; then
            ls_options="$ls_options -a"
        fi
        
        # Filtrer selon le type si nécessaire
        if [[ "$SEARCH_TYPE" == "files" ]]; then
            # Afficher seulement les fichiers
            ls $ls_options "$search_directory" 2>/dev/null | grep -v "^d" | while IFS= read -r line; do
                if [[ -n "$line" && ! "$line" =~ ^total ]]; then
                    # Extraire les informations de la ligne ls
                    local permissions=$(echo "$line" | awk '{print $1}')
                    local size=$(echo "$line" | awk '{print $5}')
                    local date=$(echo "$line" | awk '{print $6, $7, $8}')
                    local name=$(echo "$line" | awk '{for(i=9;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ $//')
                    
                    echo -e "  ${GREEN}[FILE]${NC} $name ${YELLOW}$size${NC} ${CYAN}Mod: $date${NC}"
                fi
            done
        elif [[ "$SEARCH_TYPE" == "dirs" ]]; then
            # Afficher seulement les dossiers
            ls $ls_options "$search_directory" 2>/dev/null | grep "^d" | while IFS= read -r line; do
                if [[ -n "$line" ]]; then
                    # Extraire les informations de la ligne ls
                    local permissions=$(echo "$line" | awk '{print $1}')
                    local size=$(echo "$line" | awk '{print $5}')
                    local date=$(echo "$line" | awk '{print $6, $7, $8}')
                    local name=$(echo "$line" | awk '{for(i=9;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ $//')
                    
                    echo -e "  ${BLUE}[DIR]${NC} $name ${YELLOW}$size${NC} ${CYAN}Mod: $date${NC}"
                fi
            done
        else
            # Afficher fichiers et dossiers avec couleurs et formatage
            ls $ls_options "$search_directory" 2>/dev/null | while IFS= read -r line; do
                if [[ -n "$line" && ! "$line" =~ ^total ]]; then
                    # Extraire les informations de la ligne ls
                    local permissions=$(echo "$line" | awk '{print $1}')
                    local size=$(echo "$line" | awk '{print $5}')
                    local date=$(echo "$line" | awk '{print $6, $7, $8}')
                    local name=$(echo "$line" | awk '{for(i=9;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ $//')
                    
                    if [[ "$line" =~ ^d ]]; then
                        echo -e "  ${BLUE}[DIR]${NC} $name ${YELLOW}$size${NC} ${CYAN}Mod: $date${NC}"
                    else
                        echo -e "  ${GREEN}[FILE]${NC} $name ${YELLOW}$size${NC} ${CYAN}Mod: $date${NC}"
                    fi
                fi
            done
        fi
        exit 0
    fi
    
    # Vérifier que le répertoire existe
    if [[ ! -d "$search_directory" ]]; then
        echo -e "${RED}Erreur: Le répertoire '$search_directory' n'existe pas${NC}"
        exit 1
    fi
    
    # Afficher les paramètres de recherche
    echo -e "${WHITE}=== Recherche ===${NC}"
    echo -e "${CYAN}Pattern:${NC} $search_pattern"
    echo -e "${CYAN}Répertoire:${NC} $search_directory"
    echo -e "${CYAN}Type:${NC} $SEARCH_TYPE"
    echo -e "${CYAN}Mode regex:${NC} $REGEX_MODE"
    echo -e "${CYAN}Recherche exacte:${NC} $EXACT_MATCH"
    echo -e "${CYAN}Spotlight:${NC} $USE_SPOTLIGHT"
    echo -e "${CYAN}Cas sensible:${NC} $CASE_SENSITIVE"
    echo -e "${CYAN}Fichiers cachés:${NC} $SHOW_HIDDEN"
    if [[ -n "$MAX_DEPTH" ]]; then
        echo -e "${CYAN}Profondeur max:${NC} $MAX_DEPTH"
    fi
    if [[ -n "$MIN_SIZE" ]]; then
        echo -e "${CYAN}Taille min:${NC} $MIN_SIZE"
    fi
    if [[ -n "$MAX_SIZE" ]]; then
        echo -e "${CYAN}Taille max:${NC} $MAX_SIZE"
    fi
    if [[ -n "$MODIFIED_DAYS" ]]; then
        echo -e "${CYAN}Modifié dans:${NC} $MODIFIED_DAYS jours"
    fi
    echo ""
    
    # Effectuer la recherche
    if [[ "$search_content_flag" == true ]]; then
        search_content "$search_pattern" "$search_directory"
    elif [[ "$USE_SPOTLIGHT" == true ]]; then
        search_spotlight "$search_pattern" "$search_directory"
    else
        search_files "$search_pattern" "$search_directory"
    fi
}

# Exécuter le programme principal
main "$@"
