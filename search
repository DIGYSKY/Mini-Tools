#!/bin/bash

# Search - Outil de recherche avancé pour fichiers et dossiers
# Version: 1.0.1
# Description: Programme de recherche global pour rechercher facilement dans le dossier courant

# Couleurs pour l'affichage
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Variables par défaut
SEARCH_DIR="."
SEARCH_PATTERN=""
SEARCH_TYPE="both"  # both, files, dirs
CASE_SENSITIVE=true
REGEX_MODE=false
EXACT_MATCH=false  # Recherche exacte du nom (non stricte)
USE_SPOTLIGHT=false  # Utiliser l'index Spotlight de macOS
SHOW_HIDDEN=false
MAX_DEPTH="1"  # Profondeur par défaut de 1 (répertoire courant uniquement)
MIN_SIZE=""
MAX_SIZE=""
MODIFIED_DAYS=""
OUTPUT_FORMAT="detailed"  # detailed, simple, json

# Fonction d'aide
show_help() {
    echo -e "${WHITE}Search - Outil de recherche avancé${NC}"
    echo -e "${CYAN}Usage: search [OPTIONS] [PATTERN] [DIRECTORY]${NC}"
    echo ""
    echo -e "${YELLOW}COMPORTEMENT PAR DÉFAUT:${NC}"
    echo -e "  ${GREEN}search${NC}                      # Affiche le contenu du dossier courant"
    echo -e "  ${GREEN}search PATTERN${NC}              # Recherche PATTERN dans le dossier courant"
    echo ""
    echo -e "${YELLOW}OPTIONS:${NC}"
    echo -e "  ${GREEN}-h, --help${NC}              Afficher cette aide"
    echo -e "  ${GREEN}-d, --directory DIR${NC}     Répertoire de recherche (défaut: .)"
    echo -e "  ${GREEN}-t, --type TYPE${NC}         Type: files, dirs, both (défaut: both)"
    echo -e "  ${GREEN}-i, --ignore-case${NC}       Ignorer la casse"
    echo -e "  ${GREEN}-r, --regex${NC}             Utiliser les expressions régulières"
    echo -e "  ${GREEN}-e, --exact${NC}             Recherche exacte du nom (non stricte)"
    echo -e "  ${GREEN}-s, --spotlight${NC}         Utiliser l'index Spotlight de macOS (plus rapide, limitation de répertoire limitée)"
    echo -e "  ${GREEN}-a, --all${NC}               Inclure les fichiers cachés"
    echo -e "  ${GREEN}-mdh, --max-depth N${NC}           Profondeur maximale de recherche (défaut: 1)"
    echo -e "  ${GREEN}-mis, --min-size SIZE${NC}         Taille minimale (ex: 1M, 100K)"
    echo -e "  ${GREEN}-mas, --max-size SIZE${NC}         Taille maximale (ex: 10M, 1G)"
    echo -e "  ${GREEN}-md, --modified N${NC}            Modifié dans les N derniers jours"
    echo -e "  ${GREEN}-fo, --format FORMAT${NC}         Format de sortie: detailed, simple, json"
    echo ""
    echo -e "${YELLOW}EXEMPLES:${NC}"
    echo -e "  ${CYAN}search${NC}                            # Afficher le contenu du dossier courant"
    echo -e "  ${CYAN}search \"*.py\"${NC}                    # Rechercher tous les fichiers Python"
    echo -e "  ${CYAN}search -t files \"config\"${NC}         # Rechercher fichiers contenant 'config'"
    echo -e "  ${CYAN}search -e \"mini\"${NC}                 # Rechercher fichiers/dossiers nommés exactement 'mini'"
    echo -e "  ${CYAN}search -s \"python\"${NC}               # Recherche rapide avec Spotlight"
    echo -e "  ${CYAN}search -r \"^[A-Z].*\"${NC}             # Rechercher avec regex"
    echo -e "  ${CYAN}search --min-size 1M --max-size 10M${NC} # Fichiers entre 1M et 10M"
    echo -e "  ${CYAN}search --modified 7 \"*.log\"${NC}      # Fichiers .log modifiés cette semaine"
    echo ""
}

# Fonction pour convertir les tailles
parse_size() {
    local size=$1
    if [[ $size =~ ^([0-9]+)([KkMmGg]?)$ ]]; then
        local num=${BASH_REMATCH[1]}
        local unit=${BASH_REMATCH[2],,}
        case $unit in
            k) echo $((num * 1024)) ;;
            m) echo $((num * 1024 * 1024)) ;;
            g) echo $((num * 1024 * 1024 * 1024)) ;;
            *) echo $num ;;
        esac
    else
        echo "0"
    fi
}

# Fonction de recherche avec Spotlight
search_spotlight() {
    local pattern="$1"
    local search_dir="$2"
    
    # Vérifier que mdfind est disponible
    if ! command -v mdfind &> /dev/null; then
        echo -e "${RED}Erreur: mdfind n'est pas disponible. Spotlight n'est pas installé ou activé.${NC}"
        return 1
    fi
    
    # Avertissement pour les chemins relatifs avec Spotlight
    if [[ "$search_dir" == "." || "$search_dir" == "./" ]]; then
        echo -e "${YELLOW}Note: Spotlight ne peut pas se limiter strictement au répertoire courant.${NC}"
        echo -e "${YELLOW}Utilisez la recherche classique (sans -s) pour une limitation précise.${NC}"
        echo ""
        # Basculement vers la recherche classique
        search_files "$pattern" "$search_dir"
        return 0
    fi
    
    # Construire la requête Spotlight
    local mdfind_cmd="mdfind"
    
    # Ajouter le répertoire de recherche
    # Convertir le chemin relatif en chemin absolu
    local abs_search_dir
    if [[ "$search_dir" == "." || "$search_dir" == "./" ]]; then
        abs_search_dir=$(pwd)
    else
        abs_search_dir=$(cd "$search_dir" 2>/dev/null && pwd || echo "$search_dir")
    fi
    
    # Toujours utiliser -onlyin pour limiter la recherche
    mdfind_cmd="$mdfind_cmd -onlyin \"$abs_search_dir\""
    
    # Construire la requête selon le type de recherche
    local query=""
    
    if [[ "$EXACT_MATCH" == true ]]; then
        # Recherche exacte du nom
        query="kMDItemDisplayName == '$pattern'"
    elif [[ "$REGEX_MODE" == true ]]; then
        # Mode regex (Spotlight ne supporte pas les regex complexes, on utilise une approximation)
        query="kMDItemDisplayName == '*$pattern*'"
    else
        # Recherche partielle
        query="kMDItemDisplayName == '*$pattern*'"
    fi
    
    # Ajouter le type de fichier
    if [[ "$SEARCH_TYPE" == "files" ]]; then
        query="$query && kMDItemContentType != 'public.folder'"
    elif [[ "$SEARCH_TYPE" == "dirs" ]]; then
        query="$query && kMDItemContentType == 'public.folder'"
    fi
    
    # Ajouter les filtres de taille si spécifiés
    if [[ -n "$MIN_SIZE" ]]; then
        local min_bytes=$(parse_size "$MIN_SIZE")
        query="$query && kMDItemFSSize >= $min_bytes"
    fi
    
    if [[ -n "$MAX_SIZE" ]]; then
        local max_bytes=$(parse_size "$MAX_SIZE")
        query="$query && kMDItemFSSize <= $max_bytes"
    fi
    
    # Ajouter le filtre de date
    if [[ -n "$MODIFIED_DAYS" ]]; then
        local days_ago=$(date -v-${MODIFIED_DAYS}d +%Y-%m-%d 2>/dev/null || date -d "${MODIFIED_DAYS} days ago" +%Y-%m-%d 2>/dev/null)
        query="$query && kMDItemFSContentChangeDate >= '$days_ago'"
    fi
    
    # Exécuter la recherche Spotlight
    eval "$mdfind_cmd \"$query\"" 2>/dev/null | while IFS= read -r file; do
        if [[ -n "$file" && -e "$file" ]]; then
            # Vérification stricte : le fichier doit être dans le répertoire de recherche
            if [[ "$file" != "$abs_search_dir"* ]]; then
                continue
            fi
            
            # Vérifier la profondeur si spécifiée
            if [[ -n "$MAX_DEPTH" && "$MAX_DEPTH" != "1" ]]; then
                # Calculer la profondeur relative au répertoire de recherche
                local relative_path="${file#$abs_search_dir/}"
                local depth=$(echo "$relative_path" | tr -cd '/' | wc -c)
                depth=$((depth + 1))
                
                # Ignorer si la profondeur dépasse la limite
                if [[ $depth -gt $MAX_DEPTH ]]; then
                    continue
                fi
            fi
            
            # Vérifier les fichiers cachés si nécessaire
            if [[ "$SHOW_HIDDEN" == false ]]; then
                local basename=$(basename "$file")
                if [[ "$basename" =~ ^\..* ]]; then
                    continue
                fi
            fi
            
            display_result "$file"
        fi
    done
}

# Fonction de recherche principale
search_files() {
    local pattern="$1"
    local search_dir="$2"
    
    # Construire la commande find
    local find_cmd="find \"$search_dir\""
    
    # Ajouter la profondeur maximale
    if [[ -n "$MAX_DEPTH" ]]; then
        find_cmd="$find_cmd -maxdepth $MAX_DEPTH"
    fi
    
    # Ajouter le type de recherche
    case $SEARCH_TYPE in
        files) find_cmd="$find_cmd -type f" ;;
        dirs) find_cmd="$find_cmd -type d" ;;
    esac
    
    # Ajouter les fichiers cachés
    if [[ "$SHOW_HIDDEN" == false ]]; then
        find_cmd="$find_cmd -not -path '*/.*'"
    fi
    
    # Ajouter les filtres de taille
    if [[ -n "$MIN_SIZE" ]]; then
        local min_bytes=$(parse_size "$MIN_SIZE")
        find_cmd="$find_cmd -size +${min_bytes}c"
    fi
    
    if [[ -n "$MAX_SIZE" ]]; then
        local max_bytes=$(parse_size "$MAX_SIZE")
        find_cmd="$find_cmd -size -${max_bytes}c"
    fi
    
    # Ajouter le filtre de date
    if [[ -n "$MODIFIED_DAYS" ]]; then
        find_cmd="$find_cmd -mtime -$MODIFIED_DAYS"
    fi
    
    # Ajouter le pattern de nom
    if [[ "$REGEX_MODE" == true ]]; then
        find_cmd="$find_cmd -regex \".*$pattern.*\""
    elif [[ "$EXACT_MATCH" == true ]]; then
        # Recherche exacte du nom (sans extension pour les fichiers)
        if [[ "$CASE_SENSITIVE" == true ]]; then
            find_cmd="$find_cmd -name \"$pattern\""
        else
            find_cmd="$find_cmd -iname \"$pattern\""
        fi
    else
        # Recherche partielle (comportement par défaut)
        if [[ "$CASE_SENSITIVE" == true ]]; then
            find_cmd="$find_cmd -name \"*$pattern*\""
        else
            find_cmd="$find_cmd -iname \"*$pattern*\""
        fi
    fi
    
    # Exécuter la recherche
    eval "$find_cmd" 2>/dev/null | while IFS= read -r file; do
        # Nettoyer le nom de fichier et vérifier qu'il n'est pas vide
        file=$(echo "$file" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [[ -n "$file" && -e "$file" ]]; then
            display_result "$file"
        fi
    done
}

# Fonction pour afficher les résultats
display_result() {
    local file="$1"
    
    # Vérifier que le fichier existe et n'est pas vide
    if [[ -z "$file" || ! -e "$file" ]]; then
        return
    fi
    
    case $OUTPUT_FORMAT in
        simple)
            echo "$file"
            ;;
        json)
            local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
            local modified=$(stat -f%m "$file" 2>/dev/null || stat -c%Y "$file" 2>/dev/null || echo "0")
            local created=""
            if [[ "$OSTYPE" == "darwin"* ]]; then
                created=$(stat -f%B "$file" 2>/dev/null || echo "0")
            else
                created=$(stat -c%W "$file" 2>/dev/null || echo "0")
            fi
            local type="file"
            if [[ -d "$file" ]]; then
                type="directory"
            fi
            echo "{\"path\":\"$file\",\"type\":\"$type\",\"size\":$size,\"modified\":$modified,\"created\":$created}"
            ;;
        detailed|*)
            local size=""
            local modified=""
            local created=""
            local type=""
            
            if [[ -d "$file" ]]; then
                type="${BLUE}[DIR]${NC}"
                # Pour les dossiers, utiliser du -sh mais limiter la profondeur
                size=$(du -sh "$file" 2>/dev/null | cut -f1 | head -1 || echo "?")
            else
                type="${GREEN}[FILE]${NC}"
                # Pour les fichiers, utiliser ls -lh
                size=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' | head -1 || echo "?")
            fi
            
            # Obtenir la date de modification
            if [[ -d "$file" ]]; then
                # Pour les dossiers, utiliser la date du dossier lui-même
                modified=$(ls -ld "$file" 2>/dev/null | awk '{print $6, $7, $8}' | head -1 || echo "?")
            else
                # Pour les fichiers, utiliser ls -l
                modified=$(ls -l "$file" 2>/dev/null | awk '{print $6, $7, $8}' | head -1 || echo "?")
            fi
            
            # Obtenir la date de création (birth time)
            if [[ "$OSTYPE" == "darwin"* ]]; then
                # Sur macOS, utiliser stat avec -f pour birth time
                created=$(stat -f "%SB" -t "%d %b %H:%M" "$file" 2>/dev/null || echo "?")
            else
                # Sur Linux, utiliser stat avec -c pour birth time
                created=$(stat -c "%w" "$file" 2>/dev/null | awk '{print $1, $2, $3}' | sed 's/^[0-9-]* //' || echo "?")
            fi
            
            # Si la date de création n'est pas disponible, utiliser la date de modification
            if [[ "$created" == "?" || -z "$created" ]]; then
                created="$modified"
            fi
            
            # Nettoyer les variables pour éviter les lignes vides
            size=$(echo "$size" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            modified=$(echo "$modified" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            created=$(echo "$created" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # S'assurer que nous avons des valeurs valides
            if [[ -z "$size" || "$size" == "?" ]]; then
                size="?"
            fi
            if [[ -z "$modified" || "$modified" == "?" ]]; then
                modified="?"
            fi
            if [[ -z "$created" || "$created" == "?" ]]; then
                created="?"
            fi
            
            # Afficher le résultat avec les deux dates
            printf "${WHITE}%-50s${NC} ${type} ${YELLOW}%8s${NC} ${PURPLE}Mod: %s${NC} ${CYAN}Créé: %s${NC}\n" "$file" "$size" "$modified" "$created"
            ;;
    esac
}

# Fonction pour rechercher dans le contenu des fichiers
search_content() {
    local pattern="$1"
    local search_dir="$2"
    
    local grep_cmd="grep -r"
    
    if [[ "$CASE_SENSITIVE" == false ]]; then
        grep_cmd="$grep_cmd -i"
    fi
    
    if [[ "$REGEX_MODE" == true ]]; then
        grep_cmd="$grep_cmd -E"
    else
        grep_cmd="$grep_cmd -F"
    fi
    
    if [[ "$SHOW_HIDDEN" == false ]]; then
        grep_cmd="$grep_cmd --exclude-dir='.*'"
    fi
    
    grep_cmd="$grep_cmd -n \"$pattern\" \"$search_dir\""
    
    echo -e "${CYAN}Recherche dans le contenu des fichiers:${NC}"
    eval "$grep_cmd" 2>/dev/null | while IFS=: read -r file line content; do
        printf "${GREEN}%s${NC}:${YELLOW}%s${NC}: %s\n" "$file" "$line" "$content"
    done
}

# Fonction principale
main() {
    local search_pattern=""
    local search_directory="."
    local search_content_flag=false
    
    # Parser les arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -d|--directory)
                SEARCH_DIR="$2"
                shift 2
                ;;
            -t|--type)
                SEARCH_TYPE="$2"
                if [[ ! "$SEARCH_TYPE" =~ ^(files|dirs|both)$ ]]; then
                    echo -e "${RED}Erreur: Type invalide. Utilisez: files, dirs, ou both${NC}"
                    exit 1
                fi
                shift 2
                ;;
            -i|--ignore-case)
                CASE_SENSITIVE=false
                shift
                ;;
            -r|--regex)
                REGEX_MODE=true
                shift
                ;;
            -e|--exact)
                EXACT_MATCH=true
                shift
                ;;
            -s|--spotlight)
                USE_SPOTLIGHT=true
                shift
                ;;
            -a|--all)
                SHOW_HIDDEN=true
                shift
                ;;
            -mdh  --max-depth)
                MAX_DEPTH="$2"
                shift 2
                ;;
            -mis | --min-size)
                MIN_SIZE="$2"
                shift 2
                ;;
            -mas | --max-size)
                MAX_SIZE="$2"
                shift 2
                ;;
            -md | --modified)
                MODIFIED_DAYS="$2"
                shift 2
                ;;
            -fo | --format)
                OUTPUT_FORMAT="$2"
                if [[ ! "$OUTPUT_FORMAT" =~ ^(detailed|simple|json)$ ]]; then
                    echo -e "${RED}Erreur: Format invalide. Utilisez: detailed, simple, ou json${NC}"
                    exit 1
                fi
                shift 2
                ;;
            -c|--content)
                search_content_flag=true
                shift
                ;;
            -*)
                echo -e "${RED}Erreur: Option inconnue $1${NC}"
                show_help
                exit 1
                ;;
            *)
                if [[ -z "$search_pattern" ]]; then
                    search_pattern="$1"
                elif [[ "$search_directory" == "." ]]; then
                    search_directory="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Si aucun pattern n'est fourni, afficher le contenu du dossier courant
    if [[ -z "$search_pattern" ]]; then
        echo -e "${WHITE}=== Contenu du dossier courant ===${NC}"
        echo -e "${CYAN}Répertoire:${NC} $search_directory"
        echo -e "${CYAN}Type:${NC} $SEARCH_TYPE"
        echo -e "${CYAN}Profondeur max:${NC} $MAX_DEPTH"
        echo -e "${CYAN}Fichiers cachés:${NC} $SHOW_HIDDEN"
        echo ""
        
        # Afficher tous les fichiers et dossiers du répertoire courant
        local find_cmd=""
        
        if [[ "$SEARCH_TYPE" == "files" ]]; then
            find_cmd="find \"$search_directory\" -maxdepth $MAX_DEPTH -type f"
        elif [[ "$SEARCH_TYPE" == "dirs" ]]; then
            find_cmd="find \"$search_directory\" -maxdepth $MAX_DEPTH -type d"
        else
            # Afficher fichiers et dossiers
            find_cmd="find \"$search_directory\" -maxdepth $MAX_DEPTH"
        fi
        
        # Ajouter l'exclusion des fichiers cachés si l'option -a n'est pas utilisée
        if [[ "$SHOW_HIDDEN" == false ]]; then
            find_cmd="$find_cmd -not -path '*/.*'"
        fi
        
        # Exécuter la commande find
        eval "$find_cmd" 2>/dev/null | while IFS= read -r file; do
            if [[ -n "$file" && -e "$file" ]]; then
                display_result "$file"
            fi
        done
        exit 0
    fi
    
    # Vérifier que le répertoire existe
    if [[ ! -d "$search_directory" ]]; then
        echo -e "${RED}Erreur: Le répertoire '$search_directory' n'existe pas${NC}"
        exit 1
    fi
    
    # Afficher les paramètres de recherche
    echo -e "${WHITE}=== Recherche ===${NC}"
    echo -e "${CYAN}Pattern:${NC} $search_pattern"
    echo -e "${CYAN}Répertoire:${NC} $search_directory"
    echo -e "${CYAN}Type:${NC} $SEARCH_TYPE"
    echo -e "${CYAN}Mode regex:${NC} $REGEX_MODE"
    echo -e "${CYAN}Recherche exacte:${NC} $EXACT_MATCH"
    echo -e "${CYAN}Spotlight:${NC} $USE_SPOTLIGHT"
    echo -e "${CYAN}Cas sensible:${NC} $CASE_SENSITIVE"
    echo -e "${CYAN}Fichiers cachés:${NC} $SHOW_HIDDEN"
    if [[ -n "$MAX_DEPTH" ]]; then
        echo -e "${CYAN}Profondeur max:${NC} $MAX_DEPTH"
    fi
    if [[ -n "$MIN_SIZE" ]]; then
        echo -e "${CYAN}Taille min:${NC} $MIN_SIZE"
    fi
    if [[ -n "$MAX_SIZE" ]]; then
        echo -e "${CYAN}Taille max:${NC} $MAX_SIZE"
    fi
    if [[ -n "$MODIFIED_DAYS" ]]; then
        echo -e "${CYAN}Modifié dans:${NC} $MODIFIED_DAYS jours"
    fi
    echo ""
    
    # Effectuer la recherche
    if [[ "$search_content_flag" == true ]]; then
        search_content "$search_pattern" "$search_directory"
    elif [[ "$USE_SPOTLIGHT" == true ]]; then
        search_spotlight "$search_pattern" "$search_directory"
    else
        search_files "$search_pattern" "$search_directory"
    fi
}

# Exécuter le programme principal
main "$@"
